package check

// Code generated by http://github.com/gojuno/minimock (3.0.0). DO NOT EDIT.

//go:generate minimock -i github.com/circonus-labs/circonus-agent/internal/check.API -o ./api_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/circonus-labs/go-apiclient"
	"github.com/gojuno/minimock/v3"
)

// APIMock implements API
type APIMock struct {
	t minimock.Tester

	funcCreateCheckBundle          func(cfg *apiclient.CheckBundle) (cp1 *apiclient.CheckBundle, err error)
	inspectFuncCreateCheckBundle   func(cfg *apiclient.CheckBundle)
	afterCreateCheckBundleCounter  uint64
	beforeCreateCheckBundleCounter uint64
	CreateCheckBundleMock          mAPIMockCreateCheckBundle

	funcFetchBroker          func(cid apiclient.CIDType) (bp1 *apiclient.Broker, err error)
	inspectFuncFetchBroker   func(cid apiclient.CIDType)
	afterFetchBrokerCounter  uint64
	beforeFetchBrokerCounter uint64
	FetchBrokerMock          mAPIMockFetchBroker

	funcFetchBrokers          func() (bap1 *[]apiclient.Broker, err error)
	inspectFuncFetchBrokers   func()
	afterFetchBrokersCounter  uint64
	beforeFetchBrokersCounter uint64
	FetchBrokersMock          mAPIMockFetchBrokers

	funcFetchCheck          func(cid apiclient.CIDType) (cp1 *apiclient.Check, err error)
	inspectFuncFetchCheck   func(cid apiclient.CIDType)
	afterFetchCheckCounter  uint64
	beforeFetchCheckCounter uint64
	FetchCheckMock          mAPIMockFetchCheck

	funcFetchCheckBundle          func(cid apiclient.CIDType) (cp1 *apiclient.CheckBundle, err error)
	inspectFuncFetchCheckBundle   func(cid apiclient.CIDType)
	afterFetchCheckBundleCounter  uint64
	beforeFetchCheckBundleCounter uint64
	FetchCheckBundleMock          mAPIMockFetchCheckBundle

	funcFetchCheckBundleMetrics          func(cid apiclient.CIDType) (cp1 *apiclient.CheckBundleMetrics, err error)
	inspectFuncFetchCheckBundleMetrics   func(cid apiclient.CIDType)
	afterFetchCheckBundleMetricsCounter  uint64
	beforeFetchCheckBundleMetricsCounter uint64
	FetchCheckBundleMetricsMock          mAPIMockFetchCheckBundleMetrics

	funcGet          func(url string) (ba1 []byte, err error)
	inspectFuncGet   func(url string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAPIMockGet

	funcSearchCheckBundles          func(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType) (cap1 *[]apiclient.CheckBundle, err error)
	inspectFuncSearchCheckBundles   func(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType)
	afterSearchCheckBundlesCounter  uint64
	beforeSearchCheckBundlesCounter uint64
	SearchCheckBundlesMock          mAPIMockSearchCheckBundles

	funcUpdateCheckBundle          func(cfg *apiclient.CheckBundle) (cp1 *apiclient.CheckBundle, err error)
	inspectFuncUpdateCheckBundle   func(cfg *apiclient.CheckBundle)
	afterUpdateCheckBundleCounter  uint64
	beforeUpdateCheckBundleCounter uint64
	UpdateCheckBundleMock          mAPIMockUpdateCheckBundle

	funcUpdateCheckBundleMetrics          func(cfg *apiclient.CheckBundleMetrics) (cp1 *apiclient.CheckBundleMetrics, err error)
	inspectFuncUpdateCheckBundleMetrics   func(cfg *apiclient.CheckBundleMetrics)
	afterUpdateCheckBundleMetricsCounter  uint64
	beforeUpdateCheckBundleMetricsCounter uint64
	UpdateCheckBundleMetricsMock          mAPIMockUpdateCheckBundleMetrics
}

// NewAPIMock returns a mock for API
func NewAPIMock(t minimock.Tester) *APIMock {
	m := &APIMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCheckBundleMock = mAPIMockCreateCheckBundle{mock: m}
	m.CreateCheckBundleMock.callArgs = []*APIMockCreateCheckBundleParams{}

	m.FetchBrokerMock = mAPIMockFetchBroker{mock: m}
	m.FetchBrokerMock.callArgs = []*APIMockFetchBrokerParams{}

	m.FetchBrokersMock = mAPIMockFetchBrokers{mock: m}

	m.FetchCheckMock = mAPIMockFetchCheck{mock: m}
	m.FetchCheckMock.callArgs = []*APIMockFetchCheckParams{}

	m.FetchCheckBundleMock = mAPIMockFetchCheckBundle{mock: m}
	m.FetchCheckBundleMock.callArgs = []*APIMockFetchCheckBundleParams{}

	m.FetchCheckBundleMetricsMock = mAPIMockFetchCheckBundleMetrics{mock: m}
	m.FetchCheckBundleMetricsMock.callArgs = []*APIMockFetchCheckBundleMetricsParams{}

	m.GetMock = mAPIMockGet{mock: m}
	m.GetMock.callArgs = []*APIMockGetParams{}

	m.SearchCheckBundlesMock = mAPIMockSearchCheckBundles{mock: m}
	m.SearchCheckBundlesMock.callArgs = []*APIMockSearchCheckBundlesParams{}

	m.UpdateCheckBundleMock = mAPIMockUpdateCheckBundle{mock: m}
	m.UpdateCheckBundleMock.callArgs = []*APIMockUpdateCheckBundleParams{}

	m.UpdateCheckBundleMetricsMock = mAPIMockUpdateCheckBundleMetrics{mock: m}
	m.UpdateCheckBundleMetricsMock.callArgs = []*APIMockUpdateCheckBundleMetricsParams{}

	return m
}

type mAPIMockCreateCheckBundle struct {
	mock               *APIMock
	defaultExpectation *APIMockCreateCheckBundleExpectation
	expectations       []*APIMockCreateCheckBundleExpectation

	callArgs []*APIMockCreateCheckBundleParams
	mutex    sync.RWMutex
}

// APIMockCreateCheckBundleExpectation specifies expectation struct of the API.CreateCheckBundle
type APIMockCreateCheckBundleExpectation struct {
	mock    *APIMock
	params  *APIMockCreateCheckBundleParams
	results *APIMockCreateCheckBundleResults
	Counter uint64
}

// APIMockCreateCheckBundleParams contains parameters of the API.CreateCheckBundle
type APIMockCreateCheckBundleParams struct {
	cfg *apiclient.CheckBundle
}

// APIMockCreateCheckBundleResults contains results of the API.CreateCheckBundle
type APIMockCreateCheckBundleResults struct {
	cp1 *apiclient.CheckBundle
	err error
}

// Expect sets up expected params for API.CreateCheckBundle
func (mmCreateCheckBundle *mAPIMockCreateCheckBundle) Expect(cfg *apiclient.CheckBundle) *mAPIMockCreateCheckBundle {
	if mmCreateCheckBundle.mock.funcCreateCheckBundle != nil {
		mmCreateCheckBundle.mock.t.Fatalf("APIMock.CreateCheckBundle mock is already set by Set")
	}

	if mmCreateCheckBundle.defaultExpectation == nil {
		mmCreateCheckBundle.defaultExpectation = &APIMockCreateCheckBundleExpectation{}
	}

	mmCreateCheckBundle.defaultExpectation.params = &APIMockCreateCheckBundleParams{cfg}
	for _, e := range mmCreateCheckBundle.expectations {
		if minimock.Equal(e.params, mmCreateCheckBundle.defaultExpectation.params) {
			mmCreateCheckBundle.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCheckBundle.defaultExpectation.params)
		}
	}

	return mmCreateCheckBundle
}

// Inspect accepts an inspector function that has same arguments as the API.CreateCheckBundle
func (mmCreateCheckBundle *mAPIMockCreateCheckBundle) Inspect(f func(cfg *apiclient.CheckBundle)) *mAPIMockCreateCheckBundle {
	if mmCreateCheckBundle.mock.inspectFuncCreateCheckBundle != nil {
		mmCreateCheckBundle.mock.t.Fatalf("Inspect function is already set for APIMock.CreateCheckBundle")
	}

	mmCreateCheckBundle.mock.inspectFuncCreateCheckBundle = f

	return mmCreateCheckBundle
}

// Return sets up results that will be returned by API.CreateCheckBundle
func (mmCreateCheckBundle *mAPIMockCreateCheckBundle) Return(cp1 *apiclient.CheckBundle, err error) *APIMock {
	if mmCreateCheckBundle.mock.funcCreateCheckBundle != nil {
		mmCreateCheckBundle.mock.t.Fatalf("APIMock.CreateCheckBundle mock is already set by Set")
	}

	if mmCreateCheckBundle.defaultExpectation == nil {
		mmCreateCheckBundle.defaultExpectation = &APIMockCreateCheckBundleExpectation{mock: mmCreateCheckBundle.mock}
	}
	mmCreateCheckBundle.defaultExpectation.results = &APIMockCreateCheckBundleResults{cp1, err}
	return mmCreateCheckBundle.mock
}

//Set uses given function f to mock the API.CreateCheckBundle method
func (mmCreateCheckBundle *mAPIMockCreateCheckBundle) Set(f func(cfg *apiclient.CheckBundle) (cp1 *apiclient.CheckBundle, err error)) *APIMock {
	if mmCreateCheckBundle.defaultExpectation != nil {
		mmCreateCheckBundle.mock.t.Fatalf("Default expectation is already set for the API.CreateCheckBundle method")
	}

	if len(mmCreateCheckBundle.expectations) > 0 {
		mmCreateCheckBundle.mock.t.Fatalf("Some expectations are already set for the API.CreateCheckBundle method")
	}

	mmCreateCheckBundle.mock.funcCreateCheckBundle = f
	return mmCreateCheckBundle.mock
}

// When sets expectation for the API.CreateCheckBundle which will trigger the result defined by the following
// Then helper
func (mmCreateCheckBundle *mAPIMockCreateCheckBundle) When(cfg *apiclient.CheckBundle) *APIMockCreateCheckBundleExpectation {
	if mmCreateCheckBundle.mock.funcCreateCheckBundle != nil {
		mmCreateCheckBundle.mock.t.Fatalf("APIMock.CreateCheckBundle mock is already set by Set")
	}

	expectation := &APIMockCreateCheckBundleExpectation{
		mock:   mmCreateCheckBundle.mock,
		params: &APIMockCreateCheckBundleParams{cfg},
	}
	mmCreateCheckBundle.expectations = append(mmCreateCheckBundle.expectations, expectation)
	return expectation
}

// Then sets up API.CreateCheckBundle return parameters for the expectation previously defined by the When method
func (e *APIMockCreateCheckBundleExpectation) Then(cp1 *apiclient.CheckBundle, err error) *APIMock {
	e.results = &APIMockCreateCheckBundleResults{cp1, err}
	return e.mock
}

// CreateCheckBundle implements API
func (mmCreateCheckBundle *APIMock) CreateCheckBundle(cfg *apiclient.CheckBundle) (cp1 *apiclient.CheckBundle, err error) {
	mm_atomic.AddUint64(&mmCreateCheckBundle.beforeCreateCheckBundleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCheckBundle.afterCreateCheckBundleCounter, 1)

	if mmCreateCheckBundle.inspectFuncCreateCheckBundle != nil {
		mmCreateCheckBundle.inspectFuncCreateCheckBundle(cfg)
	}

	params := &APIMockCreateCheckBundleParams{cfg}

	// Record call args
	mmCreateCheckBundle.CreateCheckBundleMock.mutex.Lock()
	mmCreateCheckBundle.CreateCheckBundleMock.callArgs = append(mmCreateCheckBundle.CreateCheckBundleMock.callArgs, params)
	mmCreateCheckBundle.CreateCheckBundleMock.mutex.Unlock()

	for _, e := range mmCreateCheckBundle.CreateCheckBundleMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCheckBundle.CreateCheckBundleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCheckBundle.CreateCheckBundleMock.defaultExpectation.Counter, 1)
		want := mmCreateCheckBundle.CreateCheckBundleMock.defaultExpectation.params
		got := APIMockCreateCheckBundleParams{cfg}
		if want != nil && !minimock.Equal(*want, got) {
			mmCreateCheckBundle.t.Errorf("APIMock.CreateCheckBundle got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCreateCheckBundle.CreateCheckBundleMock.defaultExpectation.results
		if results == nil {
			mmCreateCheckBundle.t.Fatal("No results are set for the APIMock.CreateCheckBundle")
		}
		return (*results).cp1, (*results).err
	}
	if mmCreateCheckBundle.funcCreateCheckBundle != nil {
		return mmCreateCheckBundle.funcCreateCheckBundle(cfg)
	}
	mmCreateCheckBundle.t.Fatalf("Unexpected call to APIMock.CreateCheckBundle. %v", cfg)
	return
}

// CreateCheckBundleAfterCounter returns a count of finished APIMock.CreateCheckBundle invocations
func (mmCreateCheckBundle *APIMock) CreateCheckBundleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCheckBundle.afterCreateCheckBundleCounter)
}

// CreateCheckBundleBeforeCounter returns a count of APIMock.CreateCheckBundle invocations
func (mmCreateCheckBundle *APIMock) CreateCheckBundleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCheckBundle.beforeCreateCheckBundleCounter)
}

// Calls returns a list of arguments used in each call to APIMock.CreateCheckBundle.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCheckBundle *mAPIMockCreateCheckBundle) Calls() []*APIMockCreateCheckBundleParams {
	mmCreateCheckBundle.mutex.RLock()

	argCopy := make([]*APIMockCreateCheckBundleParams, len(mmCreateCheckBundle.callArgs))
	copy(argCopy, mmCreateCheckBundle.callArgs)

	mmCreateCheckBundle.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCheckBundleDone returns true if the count of the CreateCheckBundle invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockCreateCheckBundleDone() bool {
	for _, e := range m.CreateCheckBundleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCheckBundleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCheckBundleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCheckBundle != nil && mm_atomic.LoadUint64(&m.afterCreateCheckBundleCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateCheckBundleInspect logs each unmet expectation
func (m *APIMock) MinimockCreateCheckBundleInspect() {
	for _, e := range m.CreateCheckBundleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.CreateCheckBundle with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCheckBundleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCheckBundleCounter) < 1 {
		if m.CreateCheckBundleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.CreateCheckBundle")
		} else {
			m.t.Errorf("Expected call to APIMock.CreateCheckBundle with params: %#v", *m.CreateCheckBundleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCheckBundle != nil && mm_atomic.LoadUint64(&m.afterCreateCheckBundleCounter) < 1 {
		m.t.Error("Expected call to APIMock.CreateCheckBundle")
	}
}

type mAPIMockFetchBroker struct {
	mock               *APIMock
	defaultExpectation *APIMockFetchBrokerExpectation
	expectations       []*APIMockFetchBrokerExpectation

	callArgs []*APIMockFetchBrokerParams
	mutex    sync.RWMutex
}

// APIMockFetchBrokerExpectation specifies expectation struct of the API.FetchBroker
type APIMockFetchBrokerExpectation struct {
	mock    *APIMock
	params  *APIMockFetchBrokerParams
	results *APIMockFetchBrokerResults
	Counter uint64
}

// APIMockFetchBrokerParams contains parameters of the API.FetchBroker
type APIMockFetchBrokerParams struct {
	cid apiclient.CIDType
}

// APIMockFetchBrokerResults contains results of the API.FetchBroker
type APIMockFetchBrokerResults struct {
	bp1 *apiclient.Broker
	err error
}

// Expect sets up expected params for API.FetchBroker
func (mmFetchBroker *mAPIMockFetchBroker) Expect(cid apiclient.CIDType) *mAPIMockFetchBroker {
	if mmFetchBroker.mock.funcFetchBroker != nil {
		mmFetchBroker.mock.t.Fatalf("APIMock.FetchBroker mock is already set by Set")
	}

	if mmFetchBroker.defaultExpectation == nil {
		mmFetchBroker.defaultExpectation = &APIMockFetchBrokerExpectation{}
	}

	mmFetchBroker.defaultExpectation.params = &APIMockFetchBrokerParams{cid}
	for _, e := range mmFetchBroker.expectations {
		if minimock.Equal(e.params, mmFetchBroker.defaultExpectation.params) {
			mmFetchBroker.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchBroker.defaultExpectation.params)
		}
	}

	return mmFetchBroker
}

// Inspect accepts an inspector function that has same arguments as the API.FetchBroker
func (mmFetchBroker *mAPIMockFetchBroker) Inspect(f func(cid apiclient.CIDType)) *mAPIMockFetchBroker {
	if mmFetchBroker.mock.inspectFuncFetchBroker != nil {
		mmFetchBroker.mock.t.Fatalf("Inspect function is already set for APIMock.FetchBroker")
	}

	mmFetchBroker.mock.inspectFuncFetchBroker = f

	return mmFetchBroker
}

// Return sets up results that will be returned by API.FetchBroker
func (mmFetchBroker *mAPIMockFetchBroker) Return(bp1 *apiclient.Broker, err error) *APIMock {
	if mmFetchBroker.mock.funcFetchBroker != nil {
		mmFetchBroker.mock.t.Fatalf("APIMock.FetchBroker mock is already set by Set")
	}

	if mmFetchBroker.defaultExpectation == nil {
		mmFetchBroker.defaultExpectation = &APIMockFetchBrokerExpectation{mock: mmFetchBroker.mock}
	}
	mmFetchBroker.defaultExpectation.results = &APIMockFetchBrokerResults{bp1, err}
	return mmFetchBroker.mock
}

//Set uses given function f to mock the API.FetchBroker method
func (mmFetchBroker *mAPIMockFetchBroker) Set(f func(cid apiclient.CIDType) (bp1 *apiclient.Broker, err error)) *APIMock {
	if mmFetchBroker.defaultExpectation != nil {
		mmFetchBroker.mock.t.Fatalf("Default expectation is already set for the API.FetchBroker method")
	}

	if len(mmFetchBroker.expectations) > 0 {
		mmFetchBroker.mock.t.Fatalf("Some expectations are already set for the API.FetchBroker method")
	}

	mmFetchBroker.mock.funcFetchBroker = f
	return mmFetchBroker.mock
}

// When sets expectation for the API.FetchBroker which will trigger the result defined by the following
// Then helper
func (mmFetchBroker *mAPIMockFetchBroker) When(cid apiclient.CIDType) *APIMockFetchBrokerExpectation {
	if mmFetchBroker.mock.funcFetchBroker != nil {
		mmFetchBroker.mock.t.Fatalf("APIMock.FetchBroker mock is already set by Set")
	}

	expectation := &APIMockFetchBrokerExpectation{
		mock:   mmFetchBroker.mock,
		params: &APIMockFetchBrokerParams{cid},
	}
	mmFetchBroker.expectations = append(mmFetchBroker.expectations, expectation)
	return expectation
}

// Then sets up API.FetchBroker return parameters for the expectation previously defined by the When method
func (e *APIMockFetchBrokerExpectation) Then(bp1 *apiclient.Broker, err error) *APIMock {
	e.results = &APIMockFetchBrokerResults{bp1, err}
	return e.mock
}

// FetchBroker implements API
func (mmFetchBroker *APIMock) FetchBroker(cid apiclient.CIDType) (bp1 *apiclient.Broker, err error) {
	mm_atomic.AddUint64(&mmFetchBroker.beforeFetchBrokerCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchBroker.afterFetchBrokerCounter, 1)

	if mmFetchBroker.inspectFuncFetchBroker != nil {
		mmFetchBroker.inspectFuncFetchBroker(cid)
	}

	params := &APIMockFetchBrokerParams{cid}

	// Record call args
	mmFetchBroker.FetchBrokerMock.mutex.Lock()
	mmFetchBroker.FetchBrokerMock.callArgs = append(mmFetchBroker.FetchBrokerMock.callArgs, params)
	mmFetchBroker.FetchBrokerMock.mutex.Unlock()

	for _, e := range mmFetchBroker.FetchBrokerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmFetchBroker.FetchBrokerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchBroker.FetchBrokerMock.defaultExpectation.Counter, 1)
		want := mmFetchBroker.FetchBrokerMock.defaultExpectation.params
		got := APIMockFetchBrokerParams{cid}
		if want != nil && !minimock.Equal(*want, got) {
			mmFetchBroker.t.Errorf("APIMock.FetchBroker got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFetchBroker.FetchBrokerMock.defaultExpectation.results
		if results == nil {
			mmFetchBroker.t.Fatal("No results are set for the APIMock.FetchBroker")
		}
		return (*results).bp1, (*results).err
	}
	if mmFetchBroker.funcFetchBroker != nil {
		return mmFetchBroker.funcFetchBroker(cid)
	}
	mmFetchBroker.t.Fatalf("Unexpected call to APIMock.FetchBroker. %v", cid)
	return
}

// FetchBrokerAfterCounter returns a count of finished APIMock.FetchBroker invocations
func (mmFetchBroker *APIMock) FetchBrokerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchBroker.afterFetchBrokerCounter)
}

// FetchBrokerBeforeCounter returns a count of APIMock.FetchBroker invocations
func (mmFetchBroker *APIMock) FetchBrokerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchBroker.beforeFetchBrokerCounter)
}

// Calls returns a list of arguments used in each call to APIMock.FetchBroker.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchBroker *mAPIMockFetchBroker) Calls() []*APIMockFetchBrokerParams {
	mmFetchBroker.mutex.RLock()

	argCopy := make([]*APIMockFetchBrokerParams, len(mmFetchBroker.callArgs))
	copy(argCopy, mmFetchBroker.callArgs)

	mmFetchBroker.mutex.RUnlock()

	return argCopy
}

// MinimockFetchBrokerDone returns true if the count of the FetchBroker invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockFetchBrokerDone() bool {
	for _, e := range m.FetchBrokerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchBrokerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchBrokerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchBroker != nil && mm_atomic.LoadUint64(&m.afterFetchBrokerCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchBrokerInspect logs each unmet expectation
func (m *APIMock) MinimockFetchBrokerInspect() {
	for _, e := range m.FetchBrokerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.FetchBroker with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchBrokerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchBrokerCounter) < 1 {
		if m.FetchBrokerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.FetchBroker")
		} else {
			m.t.Errorf("Expected call to APIMock.FetchBroker with params: %#v", *m.FetchBrokerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchBroker != nil && mm_atomic.LoadUint64(&m.afterFetchBrokerCounter) < 1 {
		m.t.Error("Expected call to APIMock.FetchBroker")
	}
}

type mAPIMockFetchBrokers struct {
	mock               *APIMock
	defaultExpectation *APIMockFetchBrokersExpectation
	expectations       []*APIMockFetchBrokersExpectation
}

// APIMockFetchBrokersExpectation specifies expectation struct of the API.FetchBrokers
type APIMockFetchBrokersExpectation struct {
	mock *APIMock

	results *APIMockFetchBrokersResults
	Counter uint64
}

// APIMockFetchBrokersResults contains results of the API.FetchBrokers
type APIMockFetchBrokersResults struct {
	bap1 *[]apiclient.Broker
	err  error
}

// Expect sets up expected params for API.FetchBrokers
func (mmFetchBrokers *mAPIMockFetchBrokers) Expect() *mAPIMockFetchBrokers {
	if mmFetchBrokers.mock.funcFetchBrokers != nil {
		mmFetchBrokers.mock.t.Fatalf("APIMock.FetchBrokers mock is already set by Set")
	}

	if mmFetchBrokers.defaultExpectation == nil {
		mmFetchBrokers.defaultExpectation = &APIMockFetchBrokersExpectation{}
	}

	return mmFetchBrokers
}

// Inspect accepts an inspector function that has same arguments as the API.FetchBrokers
func (mmFetchBrokers *mAPIMockFetchBrokers) Inspect(f func()) *mAPIMockFetchBrokers {
	if mmFetchBrokers.mock.inspectFuncFetchBrokers != nil {
		mmFetchBrokers.mock.t.Fatalf("Inspect function is already set for APIMock.FetchBrokers")
	}

	mmFetchBrokers.mock.inspectFuncFetchBrokers = f

	return mmFetchBrokers
}

// Return sets up results that will be returned by API.FetchBrokers
func (mmFetchBrokers *mAPIMockFetchBrokers) Return(bap1 *[]apiclient.Broker, err error) *APIMock {
	if mmFetchBrokers.mock.funcFetchBrokers != nil {
		mmFetchBrokers.mock.t.Fatalf("APIMock.FetchBrokers mock is already set by Set")
	}

	if mmFetchBrokers.defaultExpectation == nil {
		mmFetchBrokers.defaultExpectation = &APIMockFetchBrokersExpectation{mock: mmFetchBrokers.mock}
	}
	mmFetchBrokers.defaultExpectation.results = &APIMockFetchBrokersResults{bap1, err}
	return mmFetchBrokers.mock
}

//Set uses given function f to mock the API.FetchBrokers method
func (mmFetchBrokers *mAPIMockFetchBrokers) Set(f func() (bap1 *[]apiclient.Broker, err error)) *APIMock {
	if mmFetchBrokers.defaultExpectation != nil {
		mmFetchBrokers.mock.t.Fatalf("Default expectation is already set for the API.FetchBrokers method")
	}

	if len(mmFetchBrokers.expectations) > 0 {
		mmFetchBrokers.mock.t.Fatalf("Some expectations are already set for the API.FetchBrokers method")
	}

	mmFetchBrokers.mock.funcFetchBrokers = f
	return mmFetchBrokers.mock
}

// FetchBrokers implements API
func (mmFetchBrokers *APIMock) FetchBrokers() (bap1 *[]apiclient.Broker, err error) {
	mm_atomic.AddUint64(&mmFetchBrokers.beforeFetchBrokersCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchBrokers.afterFetchBrokersCounter, 1)

	if mmFetchBrokers.inspectFuncFetchBrokers != nil {
		mmFetchBrokers.inspectFuncFetchBrokers()
	}

	if mmFetchBrokers.FetchBrokersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchBrokers.FetchBrokersMock.defaultExpectation.Counter, 1)

		results := mmFetchBrokers.FetchBrokersMock.defaultExpectation.results
		if results == nil {
			mmFetchBrokers.t.Fatal("No results are set for the APIMock.FetchBrokers")
		}
		return (*results).bap1, (*results).err
	}
	if mmFetchBrokers.funcFetchBrokers != nil {
		return mmFetchBrokers.funcFetchBrokers()
	}
	mmFetchBrokers.t.Fatalf("Unexpected call to APIMock.FetchBrokers.")
	return
}

// FetchBrokersAfterCounter returns a count of finished APIMock.FetchBrokers invocations
func (mmFetchBrokers *APIMock) FetchBrokersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchBrokers.afterFetchBrokersCounter)
}

// FetchBrokersBeforeCounter returns a count of APIMock.FetchBrokers invocations
func (mmFetchBrokers *APIMock) FetchBrokersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchBrokers.beforeFetchBrokersCounter)
}

// MinimockFetchBrokersDone returns true if the count of the FetchBrokers invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockFetchBrokersDone() bool {
	for _, e := range m.FetchBrokersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchBrokersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchBrokersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchBrokers != nil && mm_atomic.LoadUint64(&m.afterFetchBrokersCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchBrokersInspect logs each unmet expectation
func (m *APIMock) MinimockFetchBrokersInspect() {
	for _, e := range m.FetchBrokersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to APIMock.FetchBrokers")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchBrokersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchBrokersCounter) < 1 {
		m.t.Error("Expected call to APIMock.FetchBrokers")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchBrokers != nil && mm_atomic.LoadUint64(&m.afterFetchBrokersCounter) < 1 {
		m.t.Error("Expected call to APIMock.FetchBrokers")
	}
}

type mAPIMockFetchCheck struct {
	mock               *APIMock
	defaultExpectation *APIMockFetchCheckExpectation
	expectations       []*APIMockFetchCheckExpectation

	callArgs []*APIMockFetchCheckParams
	mutex    sync.RWMutex
}

// APIMockFetchCheckExpectation specifies expectation struct of the API.FetchCheck
type APIMockFetchCheckExpectation struct {
	mock    *APIMock
	params  *APIMockFetchCheckParams
	results *APIMockFetchCheckResults
	Counter uint64
}

// APIMockFetchCheckParams contains parameters of the API.FetchCheck
type APIMockFetchCheckParams struct {
	cid apiclient.CIDType
}

// APIMockFetchCheckResults contains results of the API.FetchCheck
type APIMockFetchCheckResults struct {
	cp1 *apiclient.Check
	err error
}

// Expect sets up expected params for API.FetchCheck
func (mmFetchCheck *mAPIMockFetchCheck) Expect(cid apiclient.CIDType) *mAPIMockFetchCheck {
	if mmFetchCheck.mock.funcFetchCheck != nil {
		mmFetchCheck.mock.t.Fatalf("APIMock.FetchCheck mock is already set by Set")
	}

	if mmFetchCheck.defaultExpectation == nil {
		mmFetchCheck.defaultExpectation = &APIMockFetchCheckExpectation{}
	}

	mmFetchCheck.defaultExpectation.params = &APIMockFetchCheckParams{cid}
	for _, e := range mmFetchCheck.expectations {
		if minimock.Equal(e.params, mmFetchCheck.defaultExpectation.params) {
			mmFetchCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchCheck.defaultExpectation.params)
		}
	}

	return mmFetchCheck
}

// Inspect accepts an inspector function that has same arguments as the API.FetchCheck
func (mmFetchCheck *mAPIMockFetchCheck) Inspect(f func(cid apiclient.CIDType)) *mAPIMockFetchCheck {
	if mmFetchCheck.mock.inspectFuncFetchCheck != nil {
		mmFetchCheck.mock.t.Fatalf("Inspect function is already set for APIMock.FetchCheck")
	}

	mmFetchCheck.mock.inspectFuncFetchCheck = f

	return mmFetchCheck
}

// Return sets up results that will be returned by API.FetchCheck
func (mmFetchCheck *mAPIMockFetchCheck) Return(cp1 *apiclient.Check, err error) *APIMock {
	if mmFetchCheck.mock.funcFetchCheck != nil {
		mmFetchCheck.mock.t.Fatalf("APIMock.FetchCheck mock is already set by Set")
	}

	if mmFetchCheck.defaultExpectation == nil {
		mmFetchCheck.defaultExpectation = &APIMockFetchCheckExpectation{mock: mmFetchCheck.mock}
	}
	mmFetchCheck.defaultExpectation.results = &APIMockFetchCheckResults{cp1, err}
	return mmFetchCheck.mock
}

//Set uses given function f to mock the API.FetchCheck method
func (mmFetchCheck *mAPIMockFetchCheck) Set(f func(cid apiclient.CIDType) (cp1 *apiclient.Check, err error)) *APIMock {
	if mmFetchCheck.defaultExpectation != nil {
		mmFetchCheck.mock.t.Fatalf("Default expectation is already set for the API.FetchCheck method")
	}

	if len(mmFetchCheck.expectations) > 0 {
		mmFetchCheck.mock.t.Fatalf("Some expectations are already set for the API.FetchCheck method")
	}

	mmFetchCheck.mock.funcFetchCheck = f
	return mmFetchCheck.mock
}

// When sets expectation for the API.FetchCheck which will trigger the result defined by the following
// Then helper
func (mmFetchCheck *mAPIMockFetchCheck) When(cid apiclient.CIDType) *APIMockFetchCheckExpectation {
	if mmFetchCheck.mock.funcFetchCheck != nil {
		mmFetchCheck.mock.t.Fatalf("APIMock.FetchCheck mock is already set by Set")
	}

	expectation := &APIMockFetchCheckExpectation{
		mock:   mmFetchCheck.mock,
		params: &APIMockFetchCheckParams{cid},
	}
	mmFetchCheck.expectations = append(mmFetchCheck.expectations, expectation)
	return expectation
}

// Then sets up API.FetchCheck return parameters for the expectation previously defined by the When method
func (e *APIMockFetchCheckExpectation) Then(cp1 *apiclient.Check, err error) *APIMock {
	e.results = &APIMockFetchCheckResults{cp1, err}
	return e.mock
}

// FetchCheck implements API
func (mmFetchCheck *APIMock) FetchCheck(cid apiclient.CIDType) (cp1 *apiclient.Check, err error) {
	mm_atomic.AddUint64(&mmFetchCheck.beforeFetchCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchCheck.afterFetchCheckCounter, 1)

	if mmFetchCheck.inspectFuncFetchCheck != nil {
		mmFetchCheck.inspectFuncFetchCheck(cid)
	}

	params := &APIMockFetchCheckParams{cid}

	// Record call args
	mmFetchCheck.FetchCheckMock.mutex.Lock()
	mmFetchCheck.FetchCheckMock.callArgs = append(mmFetchCheck.FetchCheckMock.callArgs, params)
	mmFetchCheck.FetchCheckMock.mutex.Unlock()

	for _, e := range mmFetchCheck.FetchCheckMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmFetchCheck.FetchCheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchCheck.FetchCheckMock.defaultExpectation.Counter, 1)
		want := mmFetchCheck.FetchCheckMock.defaultExpectation.params
		got := APIMockFetchCheckParams{cid}
		if want != nil && !minimock.Equal(*want, got) {
			mmFetchCheck.t.Errorf("APIMock.FetchCheck got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFetchCheck.FetchCheckMock.defaultExpectation.results
		if results == nil {
			mmFetchCheck.t.Fatal("No results are set for the APIMock.FetchCheck")
		}
		return (*results).cp1, (*results).err
	}
	if mmFetchCheck.funcFetchCheck != nil {
		return mmFetchCheck.funcFetchCheck(cid)
	}
	mmFetchCheck.t.Fatalf("Unexpected call to APIMock.FetchCheck. %v", cid)
	return
}

// FetchCheckAfterCounter returns a count of finished APIMock.FetchCheck invocations
func (mmFetchCheck *APIMock) FetchCheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCheck.afterFetchCheckCounter)
}

// FetchCheckBeforeCounter returns a count of APIMock.FetchCheck invocations
func (mmFetchCheck *APIMock) FetchCheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCheck.beforeFetchCheckCounter)
}

// Calls returns a list of arguments used in each call to APIMock.FetchCheck.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchCheck *mAPIMockFetchCheck) Calls() []*APIMockFetchCheckParams {
	mmFetchCheck.mutex.RLock()

	argCopy := make([]*APIMockFetchCheckParams, len(mmFetchCheck.callArgs))
	copy(argCopy, mmFetchCheck.callArgs)

	mmFetchCheck.mutex.RUnlock()

	return argCopy
}

// MinimockFetchCheckDone returns true if the count of the FetchCheck invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockFetchCheckDone() bool {
	for _, e := range m.FetchCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCheck != nil && mm_atomic.LoadUint64(&m.afterFetchCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchCheckInspect logs each unmet expectation
func (m *APIMock) MinimockFetchCheckInspect() {
	for _, e := range m.FetchCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.FetchCheck with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCheckCounter) < 1 {
		if m.FetchCheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.FetchCheck")
		} else {
			m.t.Errorf("Expected call to APIMock.FetchCheck with params: %#v", *m.FetchCheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCheck != nil && mm_atomic.LoadUint64(&m.afterFetchCheckCounter) < 1 {
		m.t.Error("Expected call to APIMock.FetchCheck")
	}
}

type mAPIMockFetchCheckBundle struct {
	mock               *APIMock
	defaultExpectation *APIMockFetchCheckBundleExpectation
	expectations       []*APIMockFetchCheckBundleExpectation

	callArgs []*APIMockFetchCheckBundleParams
	mutex    sync.RWMutex
}

// APIMockFetchCheckBundleExpectation specifies expectation struct of the API.FetchCheckBundle
type APIMockFetchCheckBundleExpectation struct {
	mock    *APIMock
	params  *APIMockFetchCheckBundleParams
	results *APIMockFetchCheckBundleResults
	Counter uint64
}

// APIMockFetchCheckBundleParams contains parameters of the API.FetchCheckBundle
type APIMockFetchCheckBundleParams struct {
	cid apiclient.CIDType
}

// APIMockFetchCheckBundleResults contains results of the API.FetchCheckBundle
type APIMockFetchCheckBundleResults struct {
	cp1 *apiclient.CheckBundle
	err error
}

// Expect sets up expected params for API.FetchCheckBundle
func (mmFetchCheckBundle *mAPIMockFetchCheckBundle) Expect(cid apiclient.CIDType) *mAPIMockFetchCheckBundle {
	if mmFetchCheckBundle.mock.funcFetchCheckBundle != nil {
		mmFetchCheckBundle.mock.t.Fatalf("APIMock.FetchCheckBundle mock is already set by Set")
	}

	if mmFetchCheckBundle.defaultExpectation == nil {
		mmFetchCheckBundle.defaultExpectation = &APIMockFetchCheckBundleExpectation{}
	}

	mmFetchCheckBundle.defaultExpectation.params = &APIMockFetchCheckBundleParams{cid}
	for _, e := range mmFetchCheckBundle.expectations {
		if minimock.Equal(e.params, mmFetchCheckBundle.defaultExpectation.params) {
			mmFetchCheckBundle.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchCheckBundle.defaultExpectation.params)
		}
	}

	return mmFetchCheckBundle
}

// Inspect accepts an inspector function that has same arguments as the API.FetchCheckBundle
func (mmFetchCheckBundle *mAPIMockFetchCheckBundle) Inspect(f func(cid apiclient.CIDType)) *mAPIMockFetchCheckBundle {
	if mmFetchCheckBundle.mock.inspectFuncFetchCheckBundle != nil {
		mmFetchCheckBundle.mock.t.Fatalf("Inspect function is already set for APIMock.FetchCheckBundle")
	}

	mmFetchCheckBundle.mock.inspectFuncFetchCheckBundle = f

	return mmFetchCheckBundle
}

// Return sets up results that will be returned by API.FetchCheckBundle
func (mmFetchCheckBundle *mAPIMockFetchCheckBundle) Return(cp1 *apiclient.CheckBundle, err error) *APIMock {
	if mmFetchCheckBundle.mock.funcFetchCheckBundle != nil {
		mmFetchCheckBundle.mock.t.Fatalf("APIMock.FetchCheckBundle mock is already set by Set")
	}

	if mmFetchCheckBundle.defaultExpectation == nil {
		mmFetchCheckBundle.defaultExpectation = &APIMockFetchCheckBundleExpectation{mock: mmFetchCheckBundle.mock}
	}
	mmFetchCheckBundle.defaultExpectation.results = &APIMockFetchCheckBundleResults{cp1, err}
	return mmFetchCheckBundle.mock
}

//Set uses given function f to mock the API.FetchCheckBundle method
func (mmFetchCheckBundle *mAPIMockFetchCheckBundle) Set(f func(cid apiclient.CIDType) (cp1 *apiclient.CheckBundle, err error)) *APIMock {
	if mmFetchCheckBundle.defaultExpectation != nil {
		mmFetchCheckBundle.mock.t.Fatalf("Default expectation is already set for the API.FetchCheckBundle method")
	}

	if len(mmFetchCheckBundle.expectations) > 0 {
		mmFetchCheckBundle.mock.t.Fatalf("Some expectations are already set for the API.FetchCheckBundle method")
	}

	mmFetchCheckBundle.mock.funcFetchCheckBundle = f
	return mmFetchCheckBundle.mock
}

// When sets expectation for the API.FetchCheckBundle which will trigger the result defined by the following
// Then helper
func (mmFetchCheckBundle *mAPIMockFetchCheckBundle) When(cid apiclient.CIDType) *APIMockFetchCheckBundleExpectation {
	if mmFetchCheckBundle.mock.funcFetchCheckBundle != nil {
		mmFetchCheckBundle.mock.t.Fatalf("APIMock.FetchCheckBundle mock is already set by Set")
	}

	expectation := &APIMockFetchCheckBundleExpectation{
		mock:   mmFetchCheckBundle.mock,
		params: &APIMockFetchCheckBundleParams{cid},
	}
	mmFetchCheckBundle.expectations = append(mmFetchCheckBundle.expectations, expectation)
	return expectation
}

// Then sets up API.FetchCheckBundle return parameters for the expectation previously defined by the When method
func (e *APIMockFetchCheckBundleExpectation) Then(cp1 *apiclient.CheckBundle, err error) *APIMock {
	e.results = &APIMockFetchCheckBundleResults{cp1, err}
	return e.mock
}

// FetchCheckBundle implements API
func (mmFetchCheckBundle *APIMock) FetchCheckBundle(cid apiclient.CIDType) (cp1 *apiclient.CheckBundle, err error) {
	mm_atomic.AddUint64(&mmFetchCheckBundle.beforeFetchCheckBundleCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchCheckBundle.afterFetchCheckBundleCounter, 1)

	if mmFetchCheckBundle.inspectFuncFetchCheckBundle != nil {
		mmFetchCheckBundle.inspectFuncFetchCheckBundle(cid)
	}

	params := &APIMockFetchCheckBundleParams{cid}

	// Record call args
	mmFetchCheckBundle.FetchCheckBundleMock.mutex.Lock()
	mmFetchCheckBundle.FetchCheckBundleMock.callArgs = append(mmFetchCheckBundle.FetchCheckBundleMock.callArgs, params)
	mmFetchCheckBundle.FetchCheckBundleMock.mutex.Unlock()

	for _, e := range mmFetchCheckBundle.FetchCheckBundleMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmFetchCheckBundle.FetchCheckBundleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchCheckBundle.FetchCheckBundleMock.defaultExpectation.Counter, 1)
		want := mmFetchCheckBundle.FetchCheckBundleMock.defaultExpectation.params
		got := APIMockFetchCheckBundleParams{cid}
		if want != nil && !minimock.Equal(*want, got) {
			mmFetchCheckBundle.t.Errorf("APIMock.FetchCheckBundle got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFetchCheckBundle.FetchCheckBundleMock.defaultExpectation.results
		if results == nil {
			mmFetchCheckBundle.t.Fatal("No results are set for the APIMock.FetchCheckBundle")
		}
		return (*results).cp1, (*results).err
	}
	if mmFetchCheckBundle.funcFetchCheckBundle != nil {
		return mmFetchCheckBundle.funcFetchCheckBundle(cid)
	}
	mmFetchCheckBundle.t.Fatalf("Unexpected call to APIMock.FetchCheckBundle. %v", cid)
	return
}

// FetchCheckBundleAfterCounter returns a count of finished APIMock.FetchCheckBundle invocations
func (mmFetchCheckBundle *APIMock) FetchCheckBundleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCheckBundle.afterFetchCheckBundleCounter)
}

// FetchCheckBundleBeforeCounter returns a count of APIMock.FetchCheckBundle invocations
func (mmFetchCheckBundle *APIMock) FetchCheckBundleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCheckBundle.beforeFetchCheckBundleCounter)
}

// Calls returns a list of arguments used in each call to APIMock.FetchCheckBundle.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchCheckBundle *mAPIMockFetchCheckBundle) Calls() []*APIMockFetchCheckBundleParams {
	mmFetchCheckBundle.mutex.RLock()

	argCopy := make([]*APIMockFetchCheckBundleParams, len(mmFetchCheckBundle.callArgs))
	copy(argCopy, mmFetchCheckBundle.callArgs)

	mmFetchCheckBundle.mutex.RUnlock()

	return argCopy
}

// MinimockFetchCheckBundleDone returns true if the count of the FetchCheckBundle invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockFetchCheckBundleDone() bool {
	for _, e := range m.FetchCheckBundleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCheckBundleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCheckBundle != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchCheckBundleInspect logs each unmet expectation
func (m *APIMock) MinimockFetchCheckBundleInspect() {
	for _, e := range m.FetchCheckBundleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.FetchCheckBundle with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCheckBundleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleCounter) < 1 {
		if m.FetchCheckBundleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.FetchCheckBundle")
		} else {
			m.t.Errorf("Expected call to APIMock.FetchCheckBundle with params: %#v", *m.FetchCheckBundleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCheckBundle != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleCounter) < 1 {
		m.t.Error("Expected call to APIMock.FetchCheckBundle")
	}
}

type mAPIMockFetchCheckBundleMetrics struct {
	mock               *APIMock
	defaultExpectation *APIMockFetchCheckBundleMetricsExpectation
	expectations       []*APIMockFetchCheckBundleMetricsExpectation

	callArgs []*APIMockFetchCheckBundleMetricsParams
	mutex    sync.RWMutex
}

// APIMockFetchCheckBundleMetricsExpectation specifies expectation struct of the API.FetchCheckBundleMetrics
type APIMockFetchCheckBundleMetricsExpectation struct {
	mock    *APIMock
	params  *APIMockFetchCheckBundleMetricsParams
	results *APIMockFetchCheckBundleMetricsResults
	Counter uint64
}

// APIMockFetchCheckBundleMetricsParams contains parameters of the API.FetchCheckBundleMetrics
type APIMockFetchCheckBundleMetricsParams struct {
	cid apiclient.CIDType
}

// APIMockFetchCheckBundleMetricsResults contains results of the API.FetchCheckBundleMetrics
type APIMockFetchCheckBundleMetricsResults struct {
	cp1 *apiclient.CheckBundleMetrics
	err error
}

// Expect sets up expected params for API.FetchCheckBundleMetrics
func (mmFetchCheckBundleMetrics *mAPIMockFetchCheckBundleMetrics) Expect(cid apiclient.CIDType) *mAPIMockFetchCheckBundleMetrics {
	if mmFetchCheckBundleMetrics.mock.funcFetchCheckBundleMetrics != nil {
		mmFetchCheckBundleMetrics.mock.t.Fatalf("APIMock.FetchCheckBundleMetrics mock is already set by Set")
	}

	if mmFetchCheckBundleMetrics.defaultExpectation == nil {
		mmFetchCheckBundleMetrics.defaultExpectation = &APIMockFetchCheckBundleMetricsExpectation{}
	}

	mmFetchCheckBundleMetrics.defaultExpectation.params = &APIMockFetchCheckBundleMetricsParams{cid}
	for _, e := range mmFetchCheckBundleMetrics.expectations {
		if minimock.Equal(e.params, mmFetchCheckBundleMetrics.defaultExpectation.params) {
			mmFetchCheckBundleMetrics.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchCheckBundleMetrics.defaultExpectation.params)
		}
	}

	return mmFetchCheckBundleMetrics
}

// Inspect accepts an inspector function that has same arguments as the API.FetchCheckBundleMetrics
func (mmFetchCheckBundleMetrics *mAPIMockFetchCheckBundleMetrics) Inspect(f func(cid apiclient.CIDType)) *mAPIMockFetchCheckBundleMetrics {
	if mmFetchCheckBundleMetrics.mock.inspectFuncFetchCheckBundleMetrics != nil {
		mmFetchCheckBundleMetrics.mock.t.Fatalf("Inspect function is already set for APIMock.FetchCheckBundleMetrics")
	}

	mmFetchCheckBundleMetrics.mock.inspectFuncFetchCheckBundleMetrics = f

	return mmFetchCheckBundleMetrics
}

// Return sets up results that will be returned by API.FetchCheckBundleMetrics
func (mmFetchCheckBundleMetrics *mAPIMockFetchCheckBundleMetrics) Return(cp1 *apiclient.CheckBundleMetrics, err error) *APIMock {
	if mmFetchCheckBundleMetrics.mock.funcFetchCheckBundleMetrics != nil {
		mmFetchCheckBundleMetrics.mock.t.Fatalf("APIMock.FetchCheckBundleMetrics mock is already set by Set")
	}

	if mmFetchCheckBundleMetrics.defaultExpectation == nil {
		mmFetchCheckBundleMetrics.defaultExpectation = &APIMockFetchCheckBundleMetricsExpectation{mock: mmFetchCheckBundleMetrics.mock}
	}
	mmFetchCheckBundleMetrics.defaultExpectation.results = &APIMockFetchCheckBundleMetricsResults{cp1, err}
	return mmFetchCheckBundleMetrics.mock
}

//Set uses given function f to mock the API.FetchCheckBundleMetrics method
func (mmFetchCheckBundleMetrics *mAPIMockFetchCheckBundleMetrics) Set(f func(cid apiclient.CIDType) (cp1 *apiclient.CheckBundleMetrics, err error)) *APIMock {
	if mmFetchCheckBundleMetrics.defaultExpectation != nil {
		mmFetchCheckBundleMetrics.mock.t.Fatalf("Default expectation is already set for the API.FetchCheckBundleMetrics method")
	}

	if len(mmFetchCheckBundleMetrics.expectations) > 0 {
		mmFetchCheckBundleMetrics.mock.t.Fatalf("Some expectations are already set for the API.FetchCheckBundleMetrics method")
	}

	mmFetchCheckBundleMetrics.mock.funcFetchCheckBundleMetrics = f
	return mmFetchCheckBundleMetrics.mock
}

// When sets expectation for the API.FetchCheckBundleMetrics which will trigger the result defined by the following
// Then helper
func (mmFetchCheckBundleMetrics *mAPIMockFetchCheckBundleMetrics) When(cid apiclient.CIDType) *APIMockFetchCheckBundleMetricsExpectation {
	if mmFetchCheckBundleMetrics.mock.funcFetchCheckBundleMetrics != nil {
		mmFetchCheckBundleMetrics.mock.t.Fatalf("APIMock.FetchCheckBundleMetrics mock is already set by Set")
	}

	expectation := &APIMockFetchCheckBundleMetricsExpectation{
		mock:   mmFetchCheckBundleMetrics.mock,
		params: &APIMockFetchCheckBundleMetricsParams{cid},
	}
	mmFetchCheckBundleMetrics.expectations = append(mmFetchCheckBundleMetrics.expectations, expectation)
	return expectation
}

// Then sets up API.FetchCheckBundleMetrics return parameters for the expectation previously defined by the When method
func (e *APIMockFetchCheckBundleMetricsExpectation) Then(cp1 *apiclient.CheckBundleMetrics, err error) *APIMock {
	e.results = &APIMockFetchCheckBundleMetricsResults{cp1, err}
	return e.mock
}

// FetchCheckBundleMetrics implements API
func (mmFetchCheckBundleMetrics *APIMock) FetchCheckBundleMetrics(cid apiclient.CIDType) (cp1 *apiclient.CheckBundleMetrics, err error) {
	mm_atomic.AddUint64(&mmFetchCheckBundleMetrics.beforeFetchCheckBundleMetricsCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchCheckBundleMetrics.afterFetchCheckBundleMetricsCounter, 1)

	if mmFetchCheckBundleMetrics.inspectFuncFetchCheckBundleMetrics != nil {
		mmFetchCheckBundleMetrics.inspectFuncFetchCheckBundleMetrics(cid)
	}

	params := &APIMockFetchCheckBundleMetricsParams{cid}

	// Record call args
	mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.mutex.Lock()
	mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.callArgs = append(mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.callArgs, params)
	mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.mutex.Unlock()

	for _, e := range mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.defaultExpectation.Counter, 1)
		want := mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.defaultExpectation.params
		got := APIMockFetchCheckBundleMetricsParams{cid}
		if want != nil && !minimock.Equal(*want, got) {
			mmFetchCheckBundleMetrics.t.Errorf("APIMock.FetchCheckBundleMetrics got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmFetchCheckBundleMetrics.FetchCheckBundleMetricsMock.defaultExpectation.results
		if results == nil {
			mmFetchCheckBundleMetrics.t.Fatal("No results are set for the APIMock.FetchCheckBundleMetrics")
		}
		return (*results).cp1, (*results).err
	}
	if mmFetchCheckBundleMetrics.funcFetchCheckBundleMetrics != nil {
		return mmFetchCheckBundleMetrics.funcFetchCheckBundleMetrics(cid)
	}
	mmFetchCheckBundleMetrics.t.Fatalf("Unexpected call to APIMock.FetchCheckBundleMetrics. %v", cid)
	return
}

// FetchCheckBundleMetricsAfterCounter returns a count of finished APIMock.FetchCheckBundleMetrics invocations
func (mmFetchCheckBundleMetrics *APIMock) FetchCheckBundleMetricsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCheckBundleMetrics.afterFetchCheckBundleMetricsCounter)
}

// FetchCheckBundleMetricsBeforeCounter returns a count of APIMock.FetchCheckBundleMetrics invocations
func (mmFetchCheckBundleMetrics *APIMock) FetchCheckBundleMetricsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCheckBundleMetrics.beforeFetchCheckBundleMetricsCounter)
}

// Calls returns a list of arguments used in each call to APIMock.FetchCheckBundleMetrics.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchCheckBundleMetrics *mAPIMockFetchCheckBundleMetrics) Calls() []*APIMockFetchCheckBundleMetricsParams {
	mmFetchCheckBundleMetrics.mutex.RLock()

	argCopy := make([]*APIMockFetchCheckBundleMetricsParams, len(mmFetchCheckBundleMetrics.callArgs))
	copy(argCopy, mmFetchCheckBundleMetrics.callArgs)

	mmFetchCheckBundleMetrics.mutex.RUnlock()

	return argCopy
}

// MinimockFetchCheckBundleMetricsDone returns true if the count of the FetchCheckBundleMetrics invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockFetchCheckBundleMetricsDone() bool {
	for _, e := range m.FetchCheckBundleMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCheckBundleMetricsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleMetricsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCheckBundleMetrics != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleMetricsCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchCheckBundleMetricsInspect logs each unmet expectation
func (m *APIMock) MinimockFetchCheckBundleMetricsInspect() {
	for _, e := range m.FetchCheckBundleMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.FetchCheckBundleMetrics with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCheckBundleMetricsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleMetricsCounter) < 1 {
		if m.FetchCheckBundleMetricsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.FetchCheckBundleMetrics")
		} else {
			m.t.Errorf("Expected call to APIMock.FetchCheckBundleMetrics with params: %#v", *m.FetchCheckBundleMetricsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCheckBundleMetrics != nil && mm_atomic.LoadUint64(&m.afterFetchCheckBundleMetricsCounter) < 1 {
		m.t.Error("Expected call to APIMock.FetchCheckBundleMetrics")
	}
}

type mAPIMockGet struct {
	mock               *APIMock
	defaultExpectation *APIMockGetExpectation
	expectations       []*APIMockGetExpectation

	callArgs []*APIMockGetParams
	mutex    sync.RWMutex
}

// APIMockGetExpectation specifies expectation struct of the API.Get
type APIMockGetExpectation struct {
	mock    *APIMock
	params  *APIMockGetParams
	results *APIMockGetResults
	Counter uint64
}

// APIMockGetParams contains parameters of the API.Get
type APIMockGetParams struct {
	url string
}

// APIMockGetResults contains results of the API.Get
type APIMockGetResults struct {
	ba1 []byte
	err error
}

// Expect sets up expected params for API.Get
func (mmGet *mAPIMockGet) Expect(url string) *mAPIMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("APIMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &APIMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &APIMockGetParams{url}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the API.Get
func (mmGet *mAPIMockGet) Inspect(f func(url string)) *mAPIMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for APIMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by API.Get
func (mmGet *mAPIMockGet) Return(ba1 []byte, err error) *APIMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("APIMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &APIMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &APIMockGetResults{ba1, err}
	return mmGet.mock
}

//Set uses given function f to mock the API.Get method
func (mmGet *mAPIMockGet) Set(f func(url string) (ba1 []byte, err error)) *APIMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the API.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the API.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the API.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAPIMockGet) When(url string) *APIMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("APIMock.Get mock is already set by Set")
	}

	expectation := &APIMockGetExpectation{
		mock:   mmGet.mock,
		params: &APIMockGetParams{url},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up API.Get return parameters for the expectation previously defined by the When method
func (e *APIMockGetExpectation) Then(ba1 []byte, err error) *APIMock {
	e.results = &APIMockGetResults{ba1, err}
	return e.mock
}

// Get implements API
func (mmGet *APIMock) Get(url string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(url)
	}

	params := &APIMockGetParams{url}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		want := mmGet.GetMock.defaultExpectation.params
		got := APIMockGetParams{url}
		if want != nil && !minimock.Equal(*want, got) {
			mmGet.t.Errorf("APIMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGet.GetMock.defaultExpectation.results
		if results == nil {
			mmGet.t.Fatal("No results are set for the APIMock.Get")
		}
		return (*results).ba1, (*results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(url)
	}
	mmGet.t.Fatalf("Unexpected call to APIMock.Get. %v", url)
	return
}

// GetAfterCounter returns a count of finished APIMock.Get invocations
func (mmGet *APIMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of APIMock.Get invocations
func (mmGet *APIMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to APIMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAPIMockGet) Calls() []*APIMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*APIMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *APIMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.Get")
		} else {
			m.t.Errorf("Expected call to APIMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to APIMock.Get")
	}
}

type mAPIMockSearchCheckBundles struct {
	mock               *APIMock
	defaultExpectation *APIMockSearchCheckBundlesExpectation
	expectations       []*APIMockSearchCheckBundlesExpectation

	callArgs []*APIMockSearchCheckBundlesParams
	mutex    sync.RWMutex
}

// APIMockSearchCheckBundlesExpectation specifies expectation struct of the API.SearchCheckBundles
type APIMockSearchCheckBundlesExpectation struct {
	mock    *APIMock
	params  *APIMockSearchCheckBundlesParams
	results *APIMockSearchCheckBundlesResults
	Counter uint64
}

// APIMockSearchCheckBundlesParams contains parameters of the API.SearchCheckBundles
type APIMockSearchCheckBundlesParams struct {
	searchCriteria *apiclient.SearchQueryType
	filterCriteria *apiclient.SearchFilterType
}

// APIMockSearchCheckBundlesResults contains results of the API.SearchCheckBundles
type APIMockSearchCheckBundlesResults struct {
	cap1 *[]apiclient.CheckBundle
	err  error
}

// Expect sets up expected params for API.SearchCheckBundles
func (mmSearchCheckBundles *mAPIMockSearchCheckBundles) Expect(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType) *mAPIMockSearchCheckBundles {
	if mmSearchCheckBundles.mock.funcSearchCheckBundles != nil {
		mmSearchCheckBundles.mock.t.Fatalf("APIMock.SearchCheckBundles mock is already set by Set")
	}

	if mmSearchCheckBundles.defaultExpectation == nil {
		mmSearchCheckBundles.defaultExpectation = &APIMockSearchCheckBundlesExpectation{}
	}

	mmSearchCheckBundles.defaultExpectation.params = &APIMockSearchCheckBundlesParams{searchCriteria, filterCriteria}
	for _, e := range mmSearchCheckBundles.expectations {
		if minimock.Equal(e.params, mmSearchCheckBundles.defaultExpectation.params) {
			mmSearchCheckBundles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchCheckBundles.defaultExpectation.params)
		}
	}

	return mmSearchCheckBundles
}

// Inspect accepts an inspector function that has same arguments as the API.SearchCheckBundles
func (mmSearchCheckBundles *mAPIMockSearchCheckBundles) Inspect(f func(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType)) *mAPIMockSearchCheckBundles {
	if mmSearchCheckBundles.mock.inspectFuncSearchCheckBundles != nil {
		mmSearchCheckBundles.mock.t.Fatalf("Inspect function is already set for APIMock.SearchCheckBundles")
	}

	mmSearchCheckBundles.mock.inspectFuncSearchCheckBundles = f

	return mmSearchCheckBundles
}

// Return sets up results that will be returned by API.SearchCheckBundles
func (mmSearchCheckBundles *mAPIMockSearchCheckBundles) Return(cap1 *[]apiclient.CheckBundle, err error) *APIMock {
	if mmSearchCheckBundles.mock.funcSearchCheckBundles != nil {
		mmSearchCheckBundles.mock.t.Fatalf("APIMock.SearchCheckBundles mock is already set by Set")
	}

	if mmSearchCheckBundles.defaultExpectation == nil {
		mmSearchCheckBundles.defaultExpectation = &APIMockSearchCheckBundlesExpectation{mock: mmSearchCheckBundles.mock}
	}
	mmSearchCheckBundles.defaultExpectation.results = &APIMockSearchCheckBundlesResults{cap1, err}
	return mmSearchCheckBundles.mock
}

//Set uses given function f to mock the API.SearchCheckBundles method
func (mmSearchCheckBundles *mAPIMockSearchCheckBundles) Set(f func(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType) (cap1 *[]apiclient.CheckBundle, err error)) *APIMock {
	if mmSearchCheckBundles.defaultExpectation != nil {
		mmSearchCheckBundles.mock.t.Fatalf("Default expectation is already set for the API.SearchCheckBundles method")
	}

	if len(mmSearchCheckBundles.expectations) > 0 {
		mmSearchCheckBundles.mock.t.Fatalf("Some expectations are already set for the API.SearchCheckBundles method")
	}

	mmSearchCheckBundles.mock.funcSearchCheckBundles = f
	return mmSearchCheckBundles.mock
}

// When sets expectation for the API.SearchCheckBundles which will trigger the result defined by the following
// Then helper
func (mmSearchCheckBundles *mAPIMockSearchCheckBundles) When(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType) *APIMockSearchCheckBundlesExpectation {
	if mmSearchCheckBundles.mock.funcSearchCheckBundles != nil {
		mmSearchCheckBundles.mock.t.Fatalf("APIMock.SearchCheckBundles mock is already set by Set")
	}

	expectation := &APIMockSearchCheckBundlesExpectation{
		mock:   mmSearchCheckBundles.mock,
		params: &APIMockSearchCheckBundlesParams{searchCriteria, filterCriteria},
	}
	mmSearchCheckBundles.expectations = append(mmSearchCheckBundles.expectations, expectation)
	return expectation
}

// Then sets up API.SearchCheckBundles return parameters for the expectation previously defined by the When method
func (e *APIMockSearchCheckBundlesExpectation) Then(cap1 *[]apiclient.CheckBundle, err error) *APIMock {
	e.results = &APIMockSearchCheckBundlesResults{cap1, err}
	return e.mock
}

// SearchCheckBundles implements API
func (mmSearchCheckBundles *APIMock) SearchCheckBundles(searchCriteria *apiclient.SearchQueryType, filterCriteria *apiclient.SearchFilterType) (cap1 *[]apiclient.CheckBundle, err error) {
	mm_atomic.AddUint64(&mmSearchCheckBundles.beforeSearchCheckBundlesCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchCheckBundles.afterSearchCheckBundlesCounter, 1)

	if mmSearchCheckBundles.inspectFuncSearchCheckBundles != nil {
		mmSearchCheckBundles.inspectFuncSearchCheckBundles(searchCriteria, filterCriteria)
	}

	params := &APIMockSearchCheckBundlesParams{searchCriteria, filterCriteria}

	// Record call args
	mmSearchCheckBundles.SearchCheckBundlesMock.mutex.Lock()
	mmSearchCheckBundles.SearchCheckBundlesMock.callArgs = append(mmSearchCheckBundles.SearchCheckBundlesMock.callArgs, params)
	mmSearchCheckBundles.SearchCheckBundlesMock.mutex.Unlock()

	for _, e := range mmSearchCheckBundles.SearchCheckBundlesMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cap1, e.results.err
		}
	}

	if mmSearchCheckBundles.SearchCheckBundlesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchCheckBundles.SearchCheckBundlesMock.defaultExpectation.Counter, 1)
		want := mmSearchCheckBundles.SearchCheckBundlesMock.defaultExpectation.params
		got := APIMockSearchCheckBundlesParams{searchCriteria, filterCriteria}
		if want != nil && !minimock.Equal(*want, got) {
			mmSearchCheckBundles.t.Errorf("APIMock.SearchCheckBundles got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmSearchCheckBundles.SearchCheckBundlesMock.defaultExpectation.results
		if results == nil {
			mmSearchCheckBundles.t.Fatal("No results are set for the APIMock.SearchCheckBundles")
		}
		return (*results).cap1, (*results).err
	}
	if mmSearchCheckBundles.funcSearchCheckBundles != nil {
		return mmSearchCheckBundles.funcSearchCheckBundles(searchCriteria, filterCriteria)
	}
	mmSearchCheckBundles.t.Fatalf("Unexpected call to APIMock.SearchCheckBundles. %v %v", searchCriteria, filterCriteria)
	return
}

// SearchCheckBundlesAfterCounter returns a count of finished APIMock.SearchCheckBundles invocations
func (mmSearchCheckBundles *APIMock) SearchCheckBundlesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchCheckBundles.afterSearchCheckBundlesCounter)
}

// SearchCheckBundlesBeforeCounter returns a count of APIMock.SearchCheckBundles invocations
func (mmSearchCheckBundles *APIMock) SearchCheckBundlesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchCheckBundles.beforeSearchCheckBundlesCounter)
}

// Calls returns a list of arguments used in each call to APIMock.SearchCheckBundles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchCheckBundles *mAPIMockSearchCheckBundles) Calls() []*APIMockSearchCheckBundlesParams {
	mmSearchCheckBundles.mutex.RLock()

	argCopy := make([]*APIMockSearchCheckBundlesParams, len(mmSearchCheckBundles.callArgs))
	copy(argCopy, mmSearchCheckBundles.callArgs)

	mmSearchCheckBundles.mutex.RUnlock()

	return argCopy
}

// MinimockSearchCheckBundlesDone returns true if the count of the SearchCheckBundles invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockSearchCheckBundlesDone() bool {
	for _, e := range m.SearchCheckBundlesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SearchCheckBundlesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSearchCheckBundlesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchCheckBundles != nil && mm_atomic.LoadUint64(&m.afterSearchCheckBundlesCounter) < 1 {
		return false
	}
	return true
}

// MinimockSearchCheckBundlesInspect logs each unmet expectation
func (m *APIMock) MinimockSearchCheckBundlesInspect() {
	for _, e := range m.SearchCheckBundlesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.SearchCheckBundles with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SearchCheckBundlesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSearchCheckBundlesCounter) < 1 {
		if m.SearchCheckBundlesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.SearchCheckBundles")
		} else {
			m.t.Errorf("Expected call to APIMock.SearchCheckBundles with params: %#v", *m.SearchCheckBundlesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchCheckBundles != nil && mm_atomic.LoadUint64(&m.afterSearchCheckBundlesCounter) < 1 {
		m.t.Error("Expected call to APIMock.SearchCheckBundles")
	}
}

type mAPIMockUpdateCheckBundle struct {
	mock               *APIMock
	defaultExpectation *APIMockUpdateCheckBundleExpectation
	expectations       []*APIMockUpdateCheckBundleExpectation

	callArgs []*APIMockUpdateCheckBundleParams
	mutex    sync.RWMutex
}

// APIMockUpdateCheckBundleExpectation specifies expectation struct of the API.UpdateCheckBundle
type APIMockUpdateCheckBundleExpectation struct {
	mock    *APIMock
	params  *APIMockUpdateCheckBundleParams
	results *APIMockUpdateCheckBundleResults
	Counter uint64
}

// APIMockUpdateCheckBundleParams contains parameters of the API.UpdateCheckBundle
type APIMockUpdateCheckBundleParams struct {
	cfg *apiclient.CheckBundle
}

// APIMockUpdateCheckBundleResults contains results of the API.UpdateCheckBundle
type APIMockUpdateCheckBundleResults struct {
	cp1 *apiclient.CheckBundle
	err error
}

// Expect sets up expected params for API.UpdateCheckBundle
func (mmUpdateCheckBundle *mAPIMockUpdateCheckBundle) Expect(cfg *apiclient.CheckBundle) *mAPIMockUpdateCheckBundle {
	if mmUpdateCheckBundle.mock.funcUpdateCheckBundle != nil {
		mmUpdateCheckBundle.mock.t.Fatalf("APIMock.UpdateCheckBundle mock is already set by Set")
	}

	if mmUpdateCheckBundle.defaultExpectation == nil {
		mmUpdateCheckBundle.defaultExpectation = &APIMockUpdateCheckBundleExpectation{}
	}

	mmUpdateCheckBundle.defaultExpectation.params = &APIMockUpdateCheckBundleParams{cfg}
	for _, e := range mmUpdateCheckBundle.expectations {
		if minimock.Equal(e.params, mmUpdateCheckBundle.defaultExpectation.params) {
			mmUpdateCheckBundle.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCheckBundle.defaultExpectation.params)
		}
	}

	return mmUpdateCheckBundle
}

// Inspect accepts an inspector function that has same arguments as the API.UpdateCheckBundle
func (mmUpdateCheckBundle *mAPIMockUpdateCheckBundle) Inspect(f func(cfg *apiclient.CheckBundle)) *mAPIMockUpdateCheckBundle {
	if mmUpdateCheckBundle.mock.inspectFuncUpdateCheckBundle != nil {
		mmUpdateCheckBundle.mock.t.Fatalf("Inspect function is already set for APIMock.UpdateCheckBundle")
	}

	mmUpdateCheckBundle.mock.inspectFuncUpdateCheckBundle = f

	return mmUpdateCheckBundle
}

// Return sets up results that will be returned by API.UpdateCheckBundle
func (mmUpdateCheckBundle *mAPIMockUpdateCheckBundle) Return(cp1 *apiclient.CheckBundle, err error) *APIMock {
	if mmUpdateCheckBundle.mock.funcUpdateCheckBundle != nil {
		mmUpdateCheckBundle.mock.t.Fatalf("APIMock.UpdateCheckBundle mock is already set by Set")
	}

	if mmUpdateCheckBundle.defaultExpectation == nil {
		mmUpdateCheckBundle.defaultExpectation = &APIMockUpdateCheckBundleExpectation{mock: mmUpdateCheckBundle.mock}
	}
	mmUpdateCheckBundle.defaultExpectation.results = &APIMockUpdateCheckBundleResults{cp1, err}
	return mmUpdateCheckBundle.mock
}

//Set uses given function f to mock the API.UpdateCheckBundle method
func (mmUpdateCheckBundle *mAPIMockUpdateCheckBundle) Set(f func(cfg *apiclient.CheckBundle) (cp1 *apiclient.CheckBundle, err error)) *APIMock {
	if mmUpdateCheckBundle.defaultExpectation != nil {
		mmUpdateCheckBundle.mock.t.Fatalf("Default expectation is already set for the API.UpdateCheckBundle method")
	}

	if len(mmUpdateCheckBundle.expectations) > 0 {
		mmUpdateCheckBundle.mock.t.Fatalf("Some expectations are already set for the API.UpdateCheckBundle method")
	}

	mmUpdateCheckBundle.mock.funcUpdateCheckBundle = f
	return mmUpdateCheckBundle.mock
}

// When sets expectation for the API.UpdateCheckBundle which will trigger the result defined by the following
// Then helper
func (mmUpdateCheckBundle *mAPIMockUpdateCheckBundle) When(cfg *apiclient.CheckBundle) *APIMockUpdateCheckBundleExpectation {
	if mmUpdateCheckBundle.mock.funcUpdateCheckBundle != nil {
		mmUpdateCheckBundle.mock.t.Fatalf("APIMock.UpdateCheckBundle mock is already set by Set")
	}

	expectation := &APIMockUpdateCheckBundleExpectation{
		mock:   mmUpdateCheckBundle.mock,
		params: &APIMockUpdateCheckBundleParams{cfg},
	}
	mmUpdateCheckBundle.expectations = append(mmUpdateCheckBundle.expectations, expectation)
	return expectation
}

// Then sets up API.UpdateCheckBundle return parameters for the expectation previously defined by the When method
func (e *APIMockUpdateCheckBundleExpectation) Then(cp1 *apiclient.CheckBundle, err error) *APIMock {
	e.results = &APIMockUpdateCheckBundleResults{cp1, err}
	return e.mock
}

// UpdateCheckBundle implements API
func (mmUpdateCheckBundle *APIMock) UpdateCheckBundle(cfg *apiclient.CheckBundle) (cp1 *apiclient.CheckBundle, err error) {
	mm_atomic.AddUint64(&mmUpdateCheckBundle.beforeUpdateCheckBundleCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCheckBundle.afterUpdateCheckBundleCounter, 1)

	if mmUpdateCheckBundle.inspectFuncUpdateCheckBundle != nil {
		mmUpdateCheckBundle.inspectFuncUpdateCheckBundle(cfg)
	}

	params := &APIMockUpdateCheckBundleParams{cfg}

	// Record call args
	mmUpdateCheckBundle.UpdateCheckBundleMock.mutex.Lock()
	mmUpdateCheckBundle.UpdateCheckBundleMock.callArgs = append(mmUpdateCheckBundle.UpdateCheckBundleMock.callArgs, params)
	mmUpdateCheckBundle.UpdateCheckBundleMock.mutex.Unlock()

	for _, e := range mmUpdateCheckBundle.UpdateCheckBundleMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateCheckBundle.UpdateCheckBundleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCheckBundle.UpdateCheckBundleMock.defaultExpectation.Counter, 1)
		want := mmUpdateCheckBundle.UpdateCheckBundleMock.defaultExpectation.params
		got := APIMockUpdateCheckBundleParams{cfg}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpdateCheckBundle.t.Errorf("APIMock.UpdateCheckBundle got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUpdateCheckBundle.UpdateCheckBundleMock.defaultExpectation.results
		if results == nil {
			mmUpdateCheckBundle.t.Fatal("No results are set for the APIMock.UpdateCheckBundle")
		}
		return (*results).cp1, (*results).err
	}
	if mmUpdateCheckBundle.funcUpdateCheckBundle != nil {
		return mmUpdateCheckBundle.funcUpdateCheckBundle(cfg)
	}
	mmUpdateCheckBundle.t.Fatalf("Unexpected call to APIMock.UpdateCheckBundle. %v", cfg)
	return
}

// UpdateCheckBundleAfterCounter returns a count of finished APIMock.UpdateCheckBundle invocations
func (mmUpdateCheckBundle *APIMock) UpdateCheckBundleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCheckBundle.afterUpdateCheckBundleCounter)
}

// UpdateCheckBundleBeforeCounter returns a count of APIMock.UpdateCheckBundle invocations
func (mmUpdateCheckBundle *APIMock) UpdateCheckBundleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCheckBundle.beforeUpdateCheckBundleCounter)
}

// Calls returns a list of arguments used in each call to APIMock.UpdateCheckBundle.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCheckBundle *mAPIMockUpdateCheckBundle) Calls() []*APIMockUpdateCheckBundleParams {
	mmUpdateCheckBundle.mutex.RLock()

	argCopy := make([]*APIMockUpdateCheckBundleParams, len(mmUpdateCheckBundle.callArgs))
	copy(argCopy, mmUpdateCheckBundle.callArgs)

	mmUpdateCheckBundle.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCheckBundleDone returns true if the count of the UpdateCheckBundle invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockUpdateCheckBundleDone() bool {
	for _, e := range m.UpdateCheckBundleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCheckBundleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCheckBundle != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCheckBundleInspect logs each unmet expectation
func (m *APIMock) MinimockUpdateCheckBundleInspect() {
	for _, e := range m.UpdateCheckBundleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.UpdateCheckBundle with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCheckBundleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleCounter) < 1 {
		if m.UpdateCheckBundleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.UpdateCheckBundle")
		} else {
			m.t.Errorf("Expected call to APIMock.UpdateCheckBundle with params: %#v", *m.UpdateCheckBundleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCheckBundle != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleCounter) < 1 {
		m.t.Error("Expected call to APIMock.UpdateCheckBundle")
	}
}

type mAPIMockUpdateCheckBundleMetrics struct {
	mock               *APIMock
	defaultExpectation *APIMockUpdateCheckBundleMetricsExpectation
	expectations       []*APIMockUpdateCheckBundleMetricsExpectation

	callArgs []*APIMockUpdateCheckBundleMetricsParams
	mutex    sync.RWMutex
}

// APIMockUpdateCheckBundleMetricsExpectation specifies expectation struct of the API.UpdateCheckBundleMetrics
type APIMockUpdateCheckBundleMetricsExpectation struct {
	mock    *APIMock
	params  *APIMockUpdateCheckBundleMetricsParams
	results *APIMockUpdateCheckBundleMetricsResults
	Counter uint64
}

// APIMockUpdateCheckBundleMetricsParams contains parameters of the API.UpdateCheckBundleMetrics
type APIMockUpdateCheckBundleMetricsParams struct {
	cfg *apiclient.CheckBundleMetrics
}

// APIMockUpdateCheckBundleMetricsResults contains results of the API.UpdateCheckBundleMetrics
type APIMockUpdateCheckBundleMetricsResults struct {
	cp1 *apiclient.CheckBundleMetrics
	err error
}

// Expect sets up expected params for API.UpdateCheckBundleMetrics
func (mmUpdateCheckBundleMetrics *mAPIMockUpdateCheckBundleMetrics) Expect(cfg *apiclient.CheckBundleMetrics) *mAPIMockUpdateCheckBundleMetrics {
	if mmUpdateCheckBundleMetrics.mock.funcUpdateCheckBundleMetrics != nil {
		mmUpdateCheckBundleMetrics.mock.t.Fatalf("APIMock.UpdateCheckBundleMetrics mock is already set by Set")
	}

	if mmUpdateCheckBundleMetrics.defaultExpectation == nil {
		mmUpdateCheckBundleMetrics.defaultExpectation = &APIMockUpdateCheckBundleMetricsExpectation{}
	}

	mmUpdateCheckBundleMetrics.defaultExpectation.params = &APIMockUpdateCheckBundleMetricsParams{cfg}
	for _, e := range mmUpdateCheckBundleMetrics.expectations {
		if minimock.Equal(e.params, mmUpdateCheckBundleMetrics.defaultExpectation.params) {
			mmUpdateCheckBundleMetrics.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCheckBundleMetrics.defaultExpectation.params)
		}
	}

	return mmUpdateCheckBundleMetrics
}

// Inspect accepts an inspector function that has same arguments as the API.UpdateCheckBundleMetrics
func (mmUpdateCheckBundleMetrics *mAPIMockUpdateCheckBundleMetrics) Inspect(f func(cfg *apiclient.CheckBundleMetrics)) *mAPIMockUpdateCheckBundleMetrics {
	if mmUpdateCheckBundleMetrics.mock.inspectFuncUpdateCheckBundleMetrics != nil {
		mmUpdateCheckBundleMetrics.mock.t.Fatalf("Inspect function is already set for APIMock.UpdateCheckBundleMetrics")
	}

	mmUpdateCheckBundleMetrics.mock.inspectFuncUpdateCheckBundleMetrics = f

	return mmUpdateCheckBundleMetrics
}

// Return sets up results that will be returned by API.UpdateCheckBundleMetrics
func (mmUpdateCheckBundleMetrics *mAPIMockUpdateCheckBundleMetrics) Return(cp1 *apiclient.CheckBundleMetrics, err error) *APIMock {
	if mmUpdateCheckBundleMetrics.mock.funcUpdateCheckBundleMetrics != nil {
		mmUpdateCheckBundleMetrics.mock.t.Fatalf("APIMock.UpdateCheckBundleMetrics mock is already set by Set")
	}

	if mmUpdateCheckBundleMetrics.defaultExpectation == nil {
		mmUpdateCheckBundleMetrics.defaultExpectation = &APIMockUpdateCheckBundleMetricsExpectation{mock: mmUpdateCheckBundleMetrics.mock}
	}
	mmUpdateCheckBundleMetrics.defaultExpectation.results = &APIMockUpdateCheckBundleMetricsResults{cp1, err}
	return mmUpdateCheckBundleMetrics.mock
}

//Set uses given function f to mock the API.UpdateCheckBundleMetrics method
func (mmUpdateCheckBundleMetrics *mAPIMockUpdateCheckBundleMetrics) Set(f func(cfg *apiclient.CheckBundleMetrics) (cp1 *apiclient.CheckBundleMetrics, err error)) *APIMock {
	if mmUpdateCheckBundleMetrics.defaultExpectation != nil {
		mmUpdateCheckBundleMetrics.mock.t.Fatalf("Default expectation is already set for the API.UpdateCheckBundleMetrics method")
	}

	if len(mmUpdateCheckBundleMetrics.expectations) > 0 {
		mmUpdateCheckBundleMetrics.mock.t.Fatalf("Some expectations are already set for the API.UpdateCheckBundleMetrics method")
	}

	mmUpdateCheckBundleMetrics.mock.funcUpdateCheckBundleMetrics = f
	return mmUpdateCheckBundleMetrics.mock
}

// When sets expectation for the API.UpdateCheckBundleMetrics which will trigger the result defined by the following
// Then helper
func (mmUpdateCheckBundleMetrics *mAPIMockUpdateCheckBundleMetrics) When(cfg *apiclient.CheckBundleMetrics) *APIMockUpdateCheckBundleMetricsExpectation {
	if mmUpdateCheckBundleMetrics.mock.funcUpdateCheckBundleMetrics != nil {
		mmUpdateCheckBundleMetrics.mock.t.Fatalf("APIMock.UpdateCheckBundleMetrics mock is already set by Set")
	}

	expectation := &APIMockUpdateCheckBundleMetricsExpectation{
		mock:   mmUpdateCheckBundleMetrics.mock,
		params: &APIMockUpdateCheckBundleMetricsParams{cfg},
	}
	mmUpdateCheckBundleMetrics.expectations = append(mmUpdateCheckBundleMetrics.expectations, expectation)
	return expectation
}

// Then sets up API.UpdateCheckBundleMetrics return parameters for the expectation previously defined by the When method
func (e *APIMockUpdateCheckBundleMetricsExpectation) Then(cp1 *apiclient.CheckBundleMetrics, err error) *APIMock {
	e.results = &APIMockUpdateCheckBundleMetricsResults{cp1, err}
	return e.mock
}

// UpdateCheckBundleMetrics implements API
func (mmUpdateCheckBundleMetrics *APIMock) UpdateCheckBundleMetrics(cfg *apiclient.CheckBundleMetrics) (cp1 *apiclient.CheckBundleMetrics, err error) {
	mm_atomic.AddUint64(&mmUpdateCheckBundleMetrics.beforeUpdateCheckBundleMetricsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCheckBundleMetrics.afterUpdateCheckBundleMetricsCounter, 1)

	if mmUpdateCheckBundleMetrics.inspectFuncUpdateCheckBundleMetrics != nil {
		mmUpdateCheckBundleMetrics.inspectFuncUpdateCheckBundleMetrics(cfg)
	}

	params := &APIMockUpdateCheckBundleMetricsParams{cfg}

	// Record call args
	mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.mutex.Lock()
	mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.callArgs = append(mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.callArgs, params)
	mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.mutex.Unlock()

	for _, e := range mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.defaultExpectation.Counter, 1)
		want := mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.defaultExpectation.params
		got := APIMockUpdateCheckBundleMetricsParams{cfg}
		if want != nil && !minimock.Equal(*want, got) {
			mmUpdateCheckBundleMetrics.t.Errorf("APIMock.UpdateCheckBundleMetrics got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmUpdateCheckBundleMetrics.UpdateCheckBundleMetricsMock.defaultExpectation.results
		if results == nil {
			mmUpdateCheckBundleMetrics.t.Fatal("No results are set for the APIMock.UpdateCheckBundleMetrics")
		}
		return (*results).cp1, (*results).err
	}
	if mmUpdateCheckBundleMetrics.funcUpdateCheckBundleMetrics != nil {
		return mmUpdateCheckBundleMetrics.funcUpdateCheckBundleMetrics(cfg)
	}
	mmUpdateCheckBundleMetrics.t.Fatalf("Unexpected call to APIMock.UpdateCheckBundleMetrics. %v", cfg)
	return
}

// UpdateCheckBundleMetricsAfterCounter returns a count of finished APIMock.UpdateCheckBundleMetrics invocations
func (mmUpdateCheckBundleMetrics *APIMock) UpdateCheckBundleMetricsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCheckBundleMetrics.afterUpdateCheckBundleMetricsCounter)
}

// UpdateCheckBundleMetricsBeforeCounter returns a count of APIMock.UpdateCheckBundleMetrics invocations
func (mmUpdateCheckBundleMetrics *APIMock) UpdateCheckBundleMetricsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCheckBundleMetrics.beforeUpdateCheckBundleMetricsCounter)
}

// Calls returns a list of arguments used in each call to APIMock.UpdateCheckBundleMetrics.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCheckBundleMetrics *mAPIMockUpdateCheckBundleMetrics) Calls() []*APIMockUpdateCheckBundleMetricsParams {
	mmUpdateCheckBundleMetrics.mutex.RLock()

	argCopy := make([]*APIMockUpdateCheckBundleMetricsParams, len(mmUpdateCheckBundleMetrics.callArgs))
	copy(argCopy, mmUpdateCheckBundleMetrics.callArgs)

	mmUpdateCheckBundleMetrics.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCheckBundleMetricsDone returns true if the count of the UpdateCheckBundleMetrics invocations corresponds
// the number of defined expectations
func (m *APIMock) MinimockUpdateCheckBundleMetricsDone() bool {
	for _, e := range m.UpdateCheckBundleMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCheckBundleMetricsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleMetricsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCheckBundleMetrics != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleMetricsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCheckBundleMetricsInspect logs each unmet expectation
func (m *APIMock) MinimockUpdateCheckBundleMetricsInspect() {
	for _, e := range m.UpdateCheckBundleMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to APIMock.UpdateCheckBundleMetrics with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCheckBundleMetricsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleMetricsCounter) < 1 {
		if m.UpdateCheckBundleMetricsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to APIMock.UpdateCheckBundleMetrics")
		} else {
			m.t.Errorf("Expected call to APIMock.UpdateCheckBundleMetrics with params: %#v", *m.UpdateCheckBundleMetricsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCheckBundleMetrics != nil && mm_atomic.LoadUint64(&m.afterUpdateCheckBundleMetricsCounter) < 1 {
		m.t.Error("Expected call to APIMock.UpdateCheckBundleMetrics")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *APIMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateCheckBundleInspect()

		m.MinimockFetchBrokerInspect()

		m.MinimockFetchBrokersInspect()

		m.MinimockFetchCheckInspect()

		m.MinimockFetchCheckBundleInspect()

		m.MinimockFetchCheckBundleMetricsInspect()

		m.MinimockGetInspect()

		m.MinimockSearchCheckBundlesInspect()

		m.MinimockUpdateCheckBundleInspect()

		m.MinimockUpdateCheckBundleMetricsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *APIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *APIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCheckBundleDone() &&
		m.MinimockFetchBrokerDone() &&
		m.MinimockFetchBrokersDone() &&
		m.MinimockFetchCheckDone() &&
		m.MinimockFetchCheckBundleDone() &&
		m.MinimockFetchCheckBundleMetricsDone() &&
		m.MinimockGetDone() &&
		m.MinimockSearchCheckBundlesDone() &&
		m.MinimockUpdateCheckBundleDone() &&
		m.MinimockUpdateCheckBundleMetricsDone()
}
