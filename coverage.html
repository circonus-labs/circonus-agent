
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/circonus-labs/circonus-agent/cmd/root.go (91.0%)</option>
				
				<option value="file1">github.com/circonus-labs/circonus-agent/internal/agent/main.go (71.4%)</option>
				
				<option value="file2">github.com/circonus-labs/circonus-agent/internal/agent/sighndlr_bsdsol.go (8.3%)</option>
				
				<option value="file3">github.com/circonus-labs/circonus-agent/internal/config/api.go (84.0%)</option>
				
				<option value="file4">github.com/circonus-labs/circonus-agent/internal/config/check_id.go (88.9%)</option>
				
				<option value="file5">github.com/circonus-labs/circonus-agent/internal/config/defaults/main.go (80.0%)</option>
				
				<option value="file6">github.com/circonus-labs/circonus-agent/internal/config/main.go (73.3%)</option>
				
				<option value="file7">github.com/circonus-labs/circonus-agent/internal/config/plugin.go (94.7%)</option>
				
				<option value="file8">github.com/circonus-labs/circonus-agent/internal/config/reverse.go (78.6%)</option>
				
				<option value="file9">github.com/circonus-labs/circonus-agent/internal/config/server.go (100.0%)</option>
				
				<option value="file10">github.com/circonus-labs/circonus-agent/internal/config/ssl.go (100.0%)</option>
				
				<option value="file11">github.com/circonus-labs/circonus-agent/internal/config/statsd.go (87.5%)</option>
				
				<option value="file12">github.com/circonus-labs/circonus-agent/internal/config/verifyfile.go (85.7%)</option>
				
				<option value="file13">github.com/circonus-labs/circonus-agent/internal/plugins/main.go (98.6%)</option>
				
				<option value="file14">github.com/circonus-labs/circonus-agent/internal/plugins/plugin.go (89.5%)</option>
				
				<option value="file15">github.com/circonus-labs/circonus-agent/internal/plugins/scan.go (93.3%)</option>
				
				<option value="file16">github.com/circonus-labs/circonus-agent/internal/release/main.go (100.0%)</option>
				
				<option value="file17">github.com/circonus-labs/circonus-agent/internal/reverse/broker.go (37.5%)</option>
				
				<option value="file18">github.com/circonus-labs/circonus-agent/internal/reverse/check.go (58.3%)</option>
				
				<option value="file19">github.com/circonus-labs/circonus-agent/internal/reverse/command.go (91.2%)</option>
				
				<option value="file20">github.com/circonus-labs/circonus-agent/internal/reverse/connection.go (66.0%)</option>
				
				<option value="file21">github.com/circonus-labs/circonus-agent/internal/reverse/main.go (90.9%)</option>
				
				<option value="file22">github.com/circonus-labs/circonus-agent/internal/reverse/metrics.go (76.7%)</option>
				
				<option value="file23">github.com/circonus-labs/circonus-agent/internal/server/handlers.go (90.6%)</option>
				
				<option value="file24">github.com/circonus-labs/circonus-agent/internal/server/main.go (88.6%)</option>
				
				<option value="file25">github.com/circonus-labs/circonus-agent/internal/server/receiver/main.go (99.1%)</option>
				
				<option value="file26">github.com/circonus-labs/circonus-agent/internal/server/routes.go (100.0%)</option>
				
				<option value="file27">github.com/circonus-labs/circonus-agent/internal/statsd/main.go (61.2%)</option>
				
				<option value="file28">github.com/circonus-labs/circonus-agent/internal/statsd/metrics.go (93.6%)</option>
				
				<option value="file29">github.com/circonus-labs/circonus-agent/main.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package cmd

import (
        "fmt"
        stdlog "log"
        "os"
        "time"

        "github.com/circonus-labs/circonus-agent/internal/agent"
        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/circonus-labs/circonus-agent/internal/config/defaults"
        "github.com/circonus-labs/circonus-agent/internal/release"
        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string

// RootCmd represents the base command when called without any subcommands
var RootCmd = &amp;cobra.Command{
        Use:   release.NAME,
        Short: "Circonus Host Agent",
        Long: `The Circonus host agent daemon provides a simple mechanism
to expose systems and application metrics to Circonus.
It inventories all executable programs in its plugin directory
and executes them upon external request, returning results
in JSON format.`,
        PersistentPreRunE: initLogging,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                //
                // show version and exit
                //
                if viper.GetBool(config.KeyShowVersion) </span><span class="cov0" title="0">{
                        fmt.Printf("%s v%s - commit: %s, date: %s, tag: %s\n", release.NAME, release.VERSION, release.COMMIT, release.DATE, release.TAG)
                        return
                }</span>

                //
                // show configuration and exit
                //
                <span class="cov0" title="0">if viper.GetString(config.KeyShowConfig) != "" </span><span class="cov0" title="0">{
                        if err := config.ShowConfig(os.Stdout); err != nil </span><span class="cov0" title="0">{
                                log.Fatal().Err(err).Msg("show-config")
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">log.Info().
                        Int("pid", os.Getpid()).
                        Str("name", release.NAME).
                        Str("ver", release.VERSION).Msg("Starting")

                a, err := agent.New()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("initializing")
                }</span>

                <span class="cov0" title="0">config.StatConfig()

                if err := a.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("starting agent")
                }</span>
        },
}

func init() <span class="cov1" title="1">{
        zerolog.TimeFieldFormat = time.RFC3339Nano
        zerolog.SetGlobalLevel(zerolog.InfoLevel)
        zlog := zerolog.New(zerolog.SyncWriter(os.Stderr)).With().Timestamp().Logger()
        log.Logger = zlog

        stdlog.SetFlags(0)
        stdlog.SetOutput(zlog)

        cobra.OnInitialize(initConfig)

        desc := func(desc, env string) string </span><span class="cov10" title="31">{
                return fmt.Sprintf("[ENV: %s] %s", env, desc)
        }</span>

        //
        // Basic
        //
        <span class="cov1" title="1">{
                var (
                        longOpt     = "config"
                        shortOpt    = "c"
                        description = "config file (default is " + defaults.EtcPath + "/" + release.NAME + ".(json|toml|yaml)"
                )
                RootCmd.PersistentFlags().StringVarP(&amp;cfgFile, longOpt, shortOpt, "", description)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyListen
                        longOpt     = "listen"
                        shortOpt    = "l"
                        envVar      = release.ENVPREFIX + "_LISTEN"
                        description = "Listen address and port [[IP]:[PORT]] " + `(default "` + defaults.Listen + `")`
                )

                RootCmd.Flags().StringP(longOpt, shortOpt, "", desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyPluginDir
                        longOpt     = "plugin-dir"
                        shortOpt    = "p"
                        envVar      = release.ENVPREFIX + "_PLUGIN_DIR"
                        description = "Plugin directory"
                )

                RootCmd.Flags().StringP(longOpt, shortOpt, defaults.PluginPath, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.PluginPath)
        }</span>

        //
        // Reverse mode
        //
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyReverse
                        longOpt     = "reverse"
                        shortOpt    = "r"
                        envVar      = release.ENVPREFIX + "_REVERSE"
                        description = "Enable reverse connection"
                )

                RootCmd.Flags().BoolP(longOpt, shortOpt, defaults.Reverse, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.Reverse)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyReverseCID
                        longOpt      = "reverse-cid"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_REVERSE_CID"
                        description  = "Check Bundle ID for reverse connection"
                )

                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyReverseTarget
                        longOpt     = "reverse-target"
                        envVar      = release.ENVPREFIX + "_REVERSE_TARGET"
                        description = "Target host"
                )

                RootCmd.Flags().String(longOpt, defaults.ReverseTarget, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.ReverseTarget)

        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyReverseCreateCheck
                        longOpt     = "reverse-create-check"
                        envVar      = release.ENVPREFIX + "_REVERSE_CREATE_CHECK"
                        description = "Create check bundle for reverse if one cannot be found"
                )

                RootCmd.Flags().Bool(longOpt, defaults.ReverseCreateCheck, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.ReverseCreateCheck)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyReverseCreateCheckBroker
                        longOpt     = "reverse-create-check-broker"
                        envVar      = release.ENVPREFIX + "_REVERSE_CREATE_CHECK_BROKER"
                        description = "ID of Broker to use or 'select' for random selection of valid broker, if creating a check bundle"
                )

                RootCmd.Flags().String(longOpt, defaults.ReverseCreateCheckBroker, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.ReverseCreateCheckBroker)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyReverseCreateCheckTitle
                        longOpt     = "reverse-create-check-title"
                        envVar      = release.ENVPREFIX + "_REVERSE_CREATE_CHECK_TITLE"
                        description = "Title [display name] to use, if creating a check bundle"
                )

                RootCmd.Flags().String(longOpt, defaults.ReverseCreateCheckTitle, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.ReverseCreateCheckTitle)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyReverseCreateCheckTags
                        longOpt     = "reverse-create-check-tags"
                        envVar      = release.ENVPREFIX + "_REVERSE_CREATE_CHECK_TAGS"
                        description = "Tags [comma separated list] to use, if creating a check bundle"
                )

                RootCmd.Flags().String(longOpt, defaults.ReverseCreateCheckTags, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.ReverseCreateCheckTags)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyReverseBrokerCAFile
                        longOpt      = "reverse-broker-ca-file"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_REVERSE_BROKER_CA_FILE"
                        description  = "Broker CA certificate file"
                )

                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        //
        // API
        //
        <span class="cov1" title="1">{
                const (
                        key          = config.KeyAPITokenKey
                        longOpt      = "api-key"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_API_KEY"
                        description  = "Circonus API Token key"
                )
                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyAPITokenApp
                        longOpt     = "api-app"
                        envVar      = release.ENVPREFIX + "_API_APP"
                        description = "Circonus API Token app"
                )

                RootCmd.Flags().String(longOpt, defaults.APIApp, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.APIApp)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyAPIURL
                        longOpt     = "api-url"
                        envVar      = release.ENVPREFIX + "_API_URL"
                        description = "Circonus API URL"
                )

                RootCmd.Flags().String(longOpt, defaults.APIURL, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.APIURL)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyAPICAFile
                        longOpt      = "api-ca-file"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_API_CA_FILE"
                        description  = "Circonus API CA certificate file"
                )

                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        //
        // SSL
        //
        <span class="cov1" title="1">{
                const (
                        key          = config.KeySSLListen
                        longOpt      = "ssl-listen"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_SSL_LISTEN"
                        description  = "SSL listen address and port [IP]:[PORT] - setting enables SSL"
                )

                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeySSLCertFile
                        longOpt     = "ssl-cert-file"
                        envVar      = release.ENVPREFIX + "_SSL_CERT_FILE"
                        description = "SSL Certificate file (PEM cert and CAs concatenated together)"
                )

                RootCmd.Flags().String(longOpt, defaults.SSLCertFile, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.SSLCertFile)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeySSLKeyFile
                        longOpt     = "ssl-key-file"
                        envVar      = release.ENVPREFIX + "_SSL_KEY_FILE"
                        description = "SSL Key file"
                )

                RootCmd.Flags().String(longOpt, defaults.SSLKeyFile, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.SSLKeyFile)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeySSLVerify
                        longOpt     = "ssl-verify"
                        envVar      = release.ENVPREFIX + "_SSL_VERIFY"
                        description = "Enable SSL verification"
                )

                RootCmd.Flags().Bool(longOpt, defaults.SSLVerify, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.SSLVerify)
        }</span>

        //
        // StatsD
        //
        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdDisabled
                        longOpt     = "no-statsd"
                        envVar      = release.ENVPREFIX + "_NO_STATSD"
                        description = "Disable StatsD listener"
                )

                RootCmd.Flags().Bool(longOpt, defaults.NoStatsd, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.NoStatsd)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdPort
                        longOpt     = "statsd-port"
                        envVar      = release.ENVPREFIX + "_STATSD_PORT"
                        description = "StatsD port"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdPort, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdPort)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdHostPrefix
                        longOpt     = "statsd-host-prefix"
                        envVar      = release.ENVPREFIX + "_STATSD_HOST_PREFIX"
                        description = "StatsD host metric prefix"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdHostPrefix, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdHostPrefix)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdHostCategory
                        longOpt     = "statsd-host-cateogry"
                        envVar      = release.ENVPREFIX + "_STATSD_HOST_CATEGORY"
                        description = "StatsD host metric category"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdHostCategory, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdHostCategory)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyStatsdGroupCID
                        longOpt      = "statsd-group-cid"
                        defaultValue = ""
                        envVar       = release.ENVPREFIX + "_STATSD_GROUP_CID"
                        description  = "StatsD group check bundle ID"
                )

                RootCmd.Flags().String(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdGroupPrefix
                        longOpt     = "statsd-group-prefix"
                        envVar      = release.ENVPREFIX + "_STATSD_GROUP_PREFIX"
                        description = "StatsD group metric prefix"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdGroupPrefix, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdGroupPrefix)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdGroupCounters
                        longOpt     = "statsd-group-counters"
                        envVar      = release.ENVPREFIX + "_STATSD_GROUP_COUNTERS"
                        description = "StatsD group metric counter handling (average|sum)"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdGroupCounters, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdGroupCounters)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdGroupGauges
                        longOpt     = "statsd-group-gauges"
                        envVar      = release.ENVPREFIX + "_STATSD_GROUP_GAUGES"
                        description = "StatsD group gauge operator"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdGroupGauges, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdGroupGauges)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyStatsdGroupSets
                        longOpt     = "statsd-group-sets"
                        envVar      = release.ENVPREFIX + "_STATSD_GROPUP_SETS"
                        description = "StatsD group set operator"
                )

                RootCmd.Flags().String(longOpt, defaults.StatsdGroupSets, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.StatsdGroupSets)
        }</span>

        // Miscellenous

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyDebug
                        longOpt     = "debug"
                        shortOpt    = "d"
                        envVar      = release.ENVPREFIX + "_DEBUG"
                        description = "Enable debug messages"
                )

                RootCmd.Flags().BoolP(longOpt, shortOpt, defaults.Debug, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.Debug)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyDebugCGM
                        longOpt      = "debug-cgm"
                        defaultValue = false
                        envVar       = release.ENVPREFIX + "_DEBUG_CGM"
                        description  = "Enable CGM &amp; API debug messages"
                )

                RootCmd.Flags().Bool(longOpt, defaultValue, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaultValue)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyLogLevel
                        longOpt     = "log-level"
                        envVar      = release.ENVPREFIX + "_LOG_LEVEL"
                        description = "Log level [(panic|fatal|error|warn|info|debug|disabled)]"
                )

                RootCmd.Flags().String(longOpt, defaults.LogLevel, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.LogLevel)
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyLogPretty
                        longOpt     = "log-pretty"
                        envVar      = release.ENVPREFIX + "_LOG_PRETTY"
                        description = "Output formatted/colored log lines"
                )

                RootCmd.Flags().Bool(longOpt, defaults.LogPretty, desc(description, envVar))
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
                viper.BindEnv(key, envVar)
                viper.SetDefault(key, defaults.LogPretty)
        }</span>

        // RootCmd.Flags().Bool("watch", defaults.Watch, "Watch plugins, reload on change")
        // viper.SetDefault("watch", defaults.Watch)
        // viper.BindPFlag("watch", RootCmd.Flags().Lookup("watch"))

        <span class="cov1" title="1">{
                const (
                        key          = config.KeyShowVersion
                        longOpt      = "version"
                        shortOpt     = "V"
                        defaultValue = false
                        description  = "Show version and exit"
                )
                RootCmd.Flags().BoolP(longOpt, shortOpt, defaultValue, description)
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
        }</span>

        <span class="cov1" title="1">{
                const (
                        key         = config.KeyShowConfig
                        longOpt     = "show-config"
                        description = "Show config (json|toml|yaml) and exit"
                )

                RootCmd.Flags().String(longOpt, "", description)
                viper.BindPFlag(key, RootCmd.Flags().Lookup(longOpt))
        }</span>
}

// initLogging initializes zerolog
func initLogging(cmd *cobra.Command, args []string) error <span class="cov6" title="9">{
        //
        // Enable formatted output
        //
        if viper.GetBool(config.KeyLogPretty) </span><span class="cov0" title="0">{
                log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout})
        }</span>

        //
        // Enable debug logging, if requested
        // otherwise, default to info level and set custom level, if specified
        //
        <span class="cov6" title="9">if viper.GetBool(config.KeyDebug) </span><span class="cov1" title="1">{
                viper.Set(config.KeyLogLevel, "debug")
                zerolog.SetGlobalLevel(zerolog.DebugLevel)
                log.Debug().Msg("--debug flag, forcing debug log level")
        }</span><span class="cov6" title="8"> else {
                if viper.IsSet(config.KeyLogLevel) </span><span class="cov6" title="8">{
                        level := viper.GetString(config.KeyLogLevel)

                        switch level </span>{
                        case "panic":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.PanicLevel)</span>
                        case "fatal":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.FatalLevel)</span>
                        case "error":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.ErrorLevel)</span>
                        case "warn":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.WarnLevel)</span>
                        case "info":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.InfoLevel)</span>
                        case "debug":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.DebugLevel)</span>
                        case "disabled":<span class="cov1" title="1">
                                zerolog.SetGlobalLevel(zerolog.Disabled)</span>
                        default:<span class="cov1" title="1">
                                return errors.Errorf("Unknown log level (%s)", level)</span>
                        }

                        <span class="cov6" title="7">log.Debug().Str("log-level", level).Msg("Logging level")</span>
                }
        }

        <span class="cov6" title="8">return nil</span>
}

// initConfig reads in config file and/or ENV variables if set.
func initConfig() <span class="cov1" title="1">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span><span class="cov1" title="1"> else {
                viper.AddConfigPath(defaults.EtcPath)
                viper.AddConfigPath(".")
                viper.SetConfigName(release.NAME)
        }</span>

        <span class="cov1" title="1">viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov1" title="1">{
                f := viper.ConfigFileUsed()
                if f != "" </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Str("config_file", f).Msg("Unable to load config file")
                }</span>
        }
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        if err := RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatal().
                        Err(err).
                        Msg("Unable to start")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package agent

import (
        "context"
        "os"
        "os/signal"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/circonus-labs/circonus-agent/internal/plugins"
        "github.com/circonus-labs/circonus-agent/internal/release"
        "github.com/circonus-labs/circonus-agent/internal/reverse"
        "github.com/circonus-labs/circonus-agent/internal/server"
        "github.com/circonus-labs/circonus-agent/internal/statsd"
        "github.com/rs/zerolog/log"
)

// New returns a new agent instance
func New() (*Agent, error) <span class="cov10" title="3">{
        var err error
        a := Agent{
                signalCh: make(chan os.Signal, 10),
        }

        //
        // validate the configuration
        //
        err = config.Validate()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">a.plugins = plugins.New(a.t.Context(context.Background()))
        err = a.plugins.Scan()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="2">a.statsdServer, err = statsd.New()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="2">a.reverseConn, err = reverse.New()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="2">a.listenServer, err = server.New(a.plugins, a.statsdServer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="2">a.signalNotifySetup()

        return &amp;a, nil</span>
}

// Start the agent
func (a *Agent) Start() error <span class="cov0" title="0">{
        a.t.Go(a.handleSignals)
        a.t.Go(a.statsdServer.Start)
        a.t.Go(a.reverseConn.Start)
        a.t.Go(a.listenServer.Start)

        log.Debug().
                Int("pid", os.Getpid()).
                Str("name", release.NAME).
                Str("ver", release.VERSION).Msg("Starting wait")

        return a.t.Wait()
}</span>

// Stop cleans up and shuts down the Agent
func (a *Agent) Stop() <span class="cov1" title="1">{
        a.stopSignalHandler()
        a.plugins.Stop()
        a.statsdServer.Stop()
        a.reverseConn.Stop()
        a.listenServer.Stop()

        a.t.Kill(nil)

        log.Debug().
                Int("pid", os.Getpid()).
                Str("name", release.NAME).
                Str("ver", release.VERSION).Msg("Stopped")
}</span>

// stopSignalHandler disables the signal handler
func (a *Agent) stopSignalHandler() <span class="cov1" title="1">{
        signal.Stop(a.signalCh)
        signal.Reset() // so a second ctrl-c will force immediate stop
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

// +build freebsd openbsd solaris darwin

// Signal handling for FreeBSD, OpenBSD, Darwin, and Solaris
// systems that have SIGINFO

package agent

import (
        "fmt"
        "os"
        "os/signal"
        "runtime"

        "github.com/alecthomas/units"
        "github.com/rs/zerolog/log"
        "golang.org/x/sys/unix"
)

func (a *Agent) signalNotifySetup() <span class="cov10" title="2">{
        signal.Notify(a.signalCh, os.Interrupt, unix.SIGTERM, unix.SIGHUP, unix.SIGPIPE, unix.SIGINFO)
}</span>

// handleSignals runs the signal handler thread
func (a *Agent) handleSignals() error <span class="cov0" title="0">{
        const stacktraceBufSize = 1 * units.MiB

        // pre-allocate a buffer
        buf := make([]byte, stacktraceBufSize)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.t.Dying():<span class="cov0" title="0">
                        return nil</span>
                case sig := &lt;-a.signalCh:<span class="cov0" title="0">
                        log.Info().Str("signal", sig.String()).Msg("Received signal")
                        switch sig </span>{
                        case os.Interrupt, unix.SIGTERM:<span class="cov0" title="0">
                                a.Stop()</span>
                        case unix.SIGPIPE, unix.SIGHUP:</span><span class="cov0" title="0">
                                // Noop
                        case unix.SIGINFO:<span class="cov0" title="0">
                                stacklen := runtime.Stack(buf, true)
                                fmt.Printf("=== received SIGINFO ===\n*** goroutine dump...\n%s\n*** end\n", buf[:stacklen])</span>
                        default:<span class="cov0" title="0">
                                log.Warn().Str("signal", sig.String()).Msg("unsupported")</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "encoding/json"
        "io/ioutil"
        "net/url"
        "strings"

        "github.com/circonus-labs/circonus-agent/internal/config/defaults"
        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

// apiRequired checks to see if any options are set which would *require* accessing the API
func apiRequired() bool <span class="cov9" title="6">{
        // reverse connections require API access
        if viper.GetBool(KeyReverse) </span><span class="cov1" title="1">{
                return true
        }</span>

        // statsd w/group check enabled require API access
        <span class="cov8" title="5">if !viper.GetBool(KeyStatsdDisabled) &amp;&amp; viper.GetString(KeyStatsdGroupCID) != "" </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov7" title="4">return false</span>
}

func validateAPIOptions() error <span class="cov10" title="7">{
        apiKey := viper.GetString(KeyAPITokenKey)
        apiApp := viper.GetString(KeyAPITokenApp)
        apiURL := viper.GetString(KeyAPIURL)
        apiCAFile := viper.GetString(KeyAPICAFile)

        // if key is 'cosi' - load the cosi api config
        if strings.ToLower(apiKey) == cosiName </span><span class="cov1" title="1">{
                cKey, cApp, cURL, err := loadCOSIConfig()
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov0" title="0">apiKey = cKey
                apiApp = cApp
                apiURL = cURL</span>
        }

        // API is required for reverse and/or statsd

        <span class="cov9" title="6">if apiKey == "" </span><span class="cov1" title="1">{
                return errors.New("API key is required")
        }</span>

        <span class="cov8" title="5">if apiApp == "" </span><span class="cov1" title="1">{
                return errors.New("API app is required")
        }</span>

        <span class="cov7" title="4">if apiURL == "" </span><span class="cov1" title="1">{
                return errors.New("API URL is required")
        }</span>

        <span class="cov6" title="3">if apiURL != defaults.APIURL </span><span class="cov6" title="3">{
                parsedURL, err := url.Parse(apiURL)
                if err != nil </span><span class="cov1" title="1">{
                        return errors.Wrap(err, "Invalid API URL")
                }</span>
                <span class="cov4" title="2">if parsedURL.Scheme == "" || parsedURL.Host == "" || parsedURL.Path == "" </span><span class="cov1" title="1">{
                        return errors.Errorf("Invalid API URL (%s)", apiURL)
                }</span>
        }

        // NOTE the api ca file doesn't come from the cosi config
        <span class="cov1" title="1">if apiCAFile != "" </span><span class="cov0" title="0">{
                f, err := verifyFile(apiCAFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">viper.Set(KeyAPICAFile, f)</span>
        }

        <span class="cov1" title="1">viper.Set(KeyAPITokenKey, apiKey)
        viper.Set(KeyAPITokenApp, apiApp)
        viper.Set(KeyAPIURL, apiURL)

        return nil</span>
}

type cosiConfig struct {
        APIKey string `json:"api_key"`
        APIApp string `json:"api_app"`
        APIURL string `json:"api_url"`
}

func loadCOSIConfig() (string, string, string, error) <span class="cov9" title="6">{
        data, err := ioutil.ReadFile(cosiCfgFile)
        if err != nil </span><span class="cov4" title="2">{
                return "", "", "", errors.Wrap(err, "Unable to access cosi config")
        }</span>

        <span class="cov7" title="4">var cfg cosiConfig
        if err := json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                return "", "", "", errors.Wrapf(err, "Unable to parse cosi config (%s)", cosiCfgFile)
        }</span>

        <span class="cov6" title="3">if cfg.APIKey == "" </span><span class="cov1" title="1">{
                return "", "", "", errors.Errorf("Missing API key, invalid cosi config (%s)", cosiCfgFile)
        }</span>
        <span class="cov4" title="2">if cfg.APIApp == "" </span><span class="cov1" title="1">{
                return "", "", "", errors.Errorf("Missing API app, invalid cosi config (%s)", cosiCfgFile)
        }</span>
        <span class="cov1" title="1">if cfg.APIURL == "" </span><span class="cov1" title="1">{
                return "", "", "", errors.Errorf("Missing API URL, invalid cosi config (%s)", cosiCfgFile)
        }</span>

        <span class="cov0" title="0">return cfg.APIKey, cfg.APIApp, cfg.APIURL, nil</span>

}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "encoding/json"
        "io/ioutil"
        "regexp"

        "github.com/pkg/errors"
)

func loadCOSICheckID(cfgFile string) (string, error) <span class="cov6" title="6">{
        data, err := ioutil.ReadFile(cfgFile)
        if err != nil </span><span class="cov4" title="3">{
                return "", errors.Wrap(err, "Unable to access cosi check config")
        }</span>

        <span class="cov4" title="3">var cfg cosiCheckConfig
        err = json.Unmarshal(data, &amp;cfg)
        if err != nil </span><span class="cov1" title="1">{
                return "", errors.Wrapf(err, "Unable to parse cosi check cosi config (%s)", cfgFile)
        }</span>
        <span class="cov3" title="2">if cfg.CID == "" </span><span class="cov1" title="1">{
                return "", errors.Errorf("Missing CID key, invalid cosi check config (%s)", cfgFile)
        }</span>

        <span class="cov1" title="1">if err := validCheckID(cfg.CID); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov1" title="1">return cfg.CID, nil</span>
}

func validCheckID(cid string) error <span class="cov10" title="21">{
        ok, err := regexp.MatchString("^(/check_bundle/)?[0-9]+$", cid)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Unable to verify Check ID (%s)", cid)
        }</span>

        <span class="cov10" title="21">if !ok </span><span class="cov4" title="3">{
                return errors.Errorf("Invalid Check ID (%s)", cid)
        }</span>

        <span class="cov9" title="18">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package defaults

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/circonus-labs/circonus-agent/internal/release"
)

const (
        // Listen defaults to all ipv4 interfaces on port 2609
        // valid formats:
        //      ip:port (e.g. 127.0.0.1:12345 - listen on 127.0.0.1, port 12345)
        //      ip (e.g. 127.0.0.1 - listen on 127.0.0.1, port default)
        //      port (e.g. 12345 - listen default, port 12345)
        //
        Listen = ":2609"

        // APIURL for circonus
        APIURL = "https://api.circonus.com/v2/"

        // APIApp defines the api app name associated with the api token key
        APIApp = release.NAME

        // Reverse is false by default
        Reverse = false

        // SSLVerify enabled by default
        SSLVerify = true

        // NoStatsd enabled by default
        NoStatsd = false

        // Debug is false by default
        Debug = false

        // LogLevel set to info by default
        LogLevel = "info"

        // LogPretty colored/formatted output to stderr
        LogPretty = false

        // UID to drop privileges to on start
        UID = "nobody"

        // Watch plugins for changes
        Watch = false

        // StatsdPort to listen, NOTE address is always localhost
        StatsdPort = "8125"

        // StatsdHostPrefix defines that metrics received through StatsD inteface
        // which are prefixed with this string plus a period go to the host check
        StatsdHostPrefix = "host."

        // StatsdHostCategory defines the "plugin" in which the host metrics will be namepspaced
        StatsdHostCategory = "statsd"

        // StatsdGroupPrefix defines that metrics received through StatsD inteface
        // which are prefixed with this string plus a period go to the group check, if enabled
        StatsdGroupPrefix = "group."

        // StatsdGroupCounters defines how group counter metrics will be handled (average or sum)
        StatsdGroupCounters = "sum"

        // StatsdGroupGauges defines how group counter metrics will be handled (average or sum)
        StatsdGroupGauges = "average"

        // StatsdGroupSets defines how group counter metrics will be handled (average or sum)
        StatsdGroupSets = "sum"

        // ReverseCreateCheck flags whether a check, for reverse, should be created if one cannot be found
        ReverseCreateCheck = false

        // ReverseCreateCheckBroker to use if creating a check, 'select' or '' will
        // result in the first broker which meets some basic criteria being selected.
        // 1. Active status
        // 2. Supports the required check type
        // 3. Responds within reverse.brokerMaxResponseTime
        ReverseCreateCheckBroker = "select"

        // ReverseCreateCheckTags to use if creating a check (comma separated list)
        ReverseCreateCheckTags = ""

        // MetricNameSeparator defines character used to delimit metric name parts
        MetricNameSeparator = "`"
)

var (
        // BasePath is the "base" directory
        //
        // expected installation structure:
        // base        (e.g. /opt/circonus/agent)
        //   /bin      (e.g. /opt/circonus/agent/bin)
        //   /etc      (e.g. /opt/circonus/agent/etc)
        //   /plugins  (e.g. /opt/circonus/agent/plugins)
        //   /sbin     (e.g. /opt/circonus/agent/sbin)
        BasePath = ""

        // EtcPath returns the default etc directory within base directory
        EtcPath = "" // (e.g. /opt/circonus/agent/etc)

        // PluginPath returns the default plugin path
        PluginPath = "" // (e.g. /opt/circonus/agent/plugins)

        // SSLCertFile returns the deefault ssl cert file name
        SSLCertFile = "" // (e.g. /opt/circonus/agent/etc/agent.pem)

        // SSLKeyFile returns the deefault ssl key file name
        SSLKeyFile = "" // (e.g. /opt/circonus/agent/etc/agent.key)

        // StatsdConf returns the default statsd config file
        StatsdConf = "" // (e.g. /opt/circonus/agent/etc/statsd.json)

        // ReverseTarget defaults to return from os.Hostname()
        ReverseTarget = ""

        // ReverseCreateCheckTitle to use if creating a check
        ReverseCreateCheckTitle = ""
)

func init() <span class="cov8" title="1">{
        var exePath string
        var resolvedExePath string
        var err error

        exePath, err = os.Executable()
        if err == nil </span><span class="cov8" title="1">{
                resolvedExePath, err = filepath.EvalSymlinks(exePath)
                if err == nil </span><span class="cov8" title="1">{
                        BasePath = filepath.Clean(filepath.Join(filepath.Dir(resolvedExePath), "..")) // e.g. /opt/circonus/agent
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Unable to determine path to binary %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">EtcPath = filepath.Join(BasePath, "etc")
        PluginPath = filepath.Join(BasePath, "plugins")
        SSLCertFile = filepath.Join(EtcPath, release.NAME+".pem")
        SSLKeyFile = filepath.Join(EtcPath, release.NAME+".key")

        ReverseTarget, err = os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Unable to determine hostname for target %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">ReverseCreateCheckTitle = ReverseTarget + " /agent"</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "encoding/json"
        "expvar"
        "fmt"
        "io"
        "net"

        "github.com/circonus-labs/circonus-agent/internal/config/defaults"
        "github.com/circonus-labs/circonus-agent/internal/release"
        toml "github.com/pelletier/go-toml"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
        yaml "gopkg.in/yaml.v2"
)

// Validate verifies the required portions of the configuration
func Validate() error <span class="cov10" title="6">{

        if err := validatePluginDirectory(); err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "plugin directory config")
        }</span>

        <span class="cov9" title="5">log.Debug().
                Str("path", viper.GetString(KeyPluginDir)).
                Msg("plugin directory")

        if viper.GetString(KeySSLListen) != "" </span><span class="cov6" title="3">{
                if err := validateSSLOptions(); err != nil </span><span class="cov4" title="2">{
                        return errors.Wrap(err, "ssl server config")
                }</span>

                <span class="cov1" title="1">log.Debug().
                        Str("listen", viper.GetString(KeySSLListen)).
                        Str("cert", viper.GetString(KeySSLCertFile)).
                        Str("key", viper.GetString(KeySSLKeyFile)).
                        Bool("verify", viper.GetBool(KeySSLVerify)).
                        Msg("ssl options")</span>
        }

        <span class="cov6" title="3">if apiRequired() </span><span class="cov0" title="0">{
                err := validateAPIOptions()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "API config")
                }</span>
        }

        <span class="cov6" title="3">if viper.GetBool(KeyReverse) </span><span class="cov0" title="0">{
                err := validateReverseOptions()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "reverse config")
                }</span>
        }

        <span class="cov6" title="3">if !viper.GetBool(KeyStatsdDisabled) </span><span class="cov0" title="0">{
                if err := validateStatsdOptions(); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "StatsD config")
                }</span>
        }

        <span class="cov6" title="3">listenSpec := viper.GetString(KeyListen)
        if listenSpec == "" &amp;&amp; viper.GetString(KeySSLListen) != "" </span><span class="cov1" title="1">{
                return nil // only ssl
        }</span>

        <span class="cov4" title="2">ip, port, err := parseListen(listenSpec, defaults.Listen)
        if err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "server config")
        }</span>
        <span class="cov1" title="1">viper.Set(KeyListen, net.JoinHostPort(ip, port))
        log.Debug().
                Str("listen", viper.GetString(KeyListen)).
                Msg("server config")

        return nil</span>
}

// StatConfig adds the running config to the app stats
func StatConfig() error <span class="cov1" title="1">{
        cfg, err := getConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">cfg.API.Key = "..."
        cfg.API.App = "..."

        expvar.Publish("config", expvar.Func(func() interface{} </span><span class="cov0" title="0">{
                return &amp;cfg
        }</span>))

        <span class="cov1" title="1">return nil</span>
}

// getConfig dumps the current configuration and returns it
func getConfig() (*Config, error) <span class="cov9" title="5">{
        var cfg *Config

        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "parsing config")
        }</span>

        <span class="cov9" title="5">return cfg, nil</span>
}

// ShowConfig prints the running configuration
func ShowConfig(w io.Writer) error <span class="cov6" title="3">{
        var cfg *Config
        var err error
        var data []byte

        cfg, err = getConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="3">format := viper.GetString(KeyShowConfig)

        log.Debug().Str("format", format).Msg("show-config")

        switch format </span>{
        case "json":<span class="cov1" title="1">
                data, err = json.MarshalIndent(cfg, " ", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "formatting config (json)")
                }</span>
        case "yaml":<span class="cov1" title="1">
                data, err = yaml.Marshal(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "formatting config (yaml)")
                }</span>
        case "toml":<span class="cov1" title="1">
                data, err = toml.Marshal(*cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "formatting config (toml)")
                }</span>
        default:<span class="cov0" title="0">
                return errors.Errorf("unknown config format '%s'", format)</span>
        }

        <span class="cov6" title="3">fmt.Fprintf(w, "%s v%s running config:\n%s\n", release.NAME, release.VERSION, data)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "os"
        "path/filepath"

        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

func validatePluginDirectory() error <span class="cov10" title="12">{
        errMsg := "Invalid plugin directory"

        pluginDir := viper.GetString(KeyPluginDir)

        if pluginDir == "" </span><span class="cov3" title="2">{
                return errors.Errorf(errMsg+" (%s)", pluginDir)
        }</span>

        <span class="cov9" title="10">absDir, err := filepath.Abs(pluginDir)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, errMsg)
        }</span>

        <span class="cov9" title="10">pluginDir = absDir

        fi, err := os.Stat(pluginDir)
        if err != nil </span><span class="cov3" title="2">{
                return errors.Wrap(err, errMsg)
        }</span>

        <span class="cov8" title="8">if !fi.Mode().IsDir() </span><span class="cov1" title="1">{
                return errors.Errorf(errMsg+" (%s) not a directory", pluginDir)
        }</span>

        // also try opening, to verify permissions
        // if last dir on path is not accessible to user, stat doesn't return EPERM
        <span class="cov8" title="7">f, err := os.Open(pluginDir)
        if err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, errMsg)
        }</span>
        <span class="cov7" title="6">f.Close()

        viper.Set(KeyPluginDir, pluginDir)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "path/filepath"
        "strings"

        "github.com/circonus-labs/circonus-agent/internal/config/defaults"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

func validateReverseOptions() error <span class="cov10" title="6">{

        cid := viper.GetString(KeyReverseCID)

        // 1. cid = 'cosi' - try to load system check registration
        if strings.ToLower(cid) == cosiName </span><span class="cov1" title="1">{
                cfgFile := filepath.Join(defaults.BasePath, "..", cosiName, "registration", "registration-check-system.json")
                cosiCID, err := loadCOSICheckID(cfgFile)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">cid = cosiCID
                viper.Set(KeyReverseCID, cid)
                log.Debug().Str("cid", cid).Msg("reverse, cosi cid")</span>
        }

        <span class="cov9" title="5">if cid != "" </span><span class="cov7" title="4">{
                // 2. explicit check bundle id
                // short form: just numeric id (e.g. --cid 123)
                // or, long form: with '/check_bundle/' prefix (e.g. --cid "/check_bundle/123")
                if err := validCheckID(cid); err != nil </span><span class="cov4" title="2">{
                        return errors.Wrap(err, "Reverse Check ID")
                }</span>
                <span class="cov4" title="2">log.Debug().Str("cid", cid).Msg("reverse, specified cid")</span>
        }

        // valid cid or, if cid empty, reverse will search for a cid
        <span class="cov6" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "net"
        "strconv"
        "strings"

        "github.com/pkg/errors"
)

func parseListen(spec, defaultSpec string) (string, string, error) <span class="cov10" title="26">{
        if spec == "" &amp;&amp; defaultSpec == "" </span><span class="cov1" title="1">{
                return "", "", nil
        }</span>

        // fixup the default spec for parsing
        <span class="cov9" title="25">if defaultSpec != "" </span><span class="cov7" title="12">{
                if !strings.Contains(defaultSpec, ":") </span><span class="cov2" title="2">{
                        if strings.Contains(defaultSpec, ".") </span><span class="cov1" title="1">{
                                defaultSpec += ":" // e.g. 127.0.0.1 -&gt; 127.0.0.1:
                        }</span><span class="cov1" title="1"> else {
                                defaultSpec = ":" + defaultSpec // e.g. 1234 -&gt; :1234
                        }</span>
                }
        }
        <span class="cov9" title="25">defaultIP, defaultPort, _ := net.SplitHostPort(defaultSpec)

        // fixup the custom spec for parsing
        if spec != "" </span><span class="cov8" title="18">{
                if !strings.Contains(spec, ":") </span><span class="cov5" title="6">{
                        if strings.Contains(spec, ".") </span><span class="cov4" title="4">{
                                spec += ":"
                        }</span><span class="cov2" title="2"> else {
                                spec = ":" + spec
                        }</span>
                }
        }
        <span class="cov9" title="25">ip, port, _ := net.SplitHostPort(spec)

        if ip == "" </span><span class="cov7" title="11">{
                ip = defaultIP
        }</span>

        <span class="cov9" title="25">if port == "" </span><span class="cov8" title="13">{
                port = defaultPort
        }</span>

        <span class="cov9" title="25">if ip == "" &amp;&amp; port == "" </span><span class="cov2" title="2">{
                return "", "", errors.Errorf("Missing IP (%s) and Port (%s) in specification (%s)", ip, port, spec)
        }</span>

        <span class="cov9" title="23">if ip != "" &amp;&amp; net.ParseIP(ip) == nil </span><span class="cov5" title="5">{
                return "", "", errors.Errorf("Invalid IP address format specified '%s'", ip)
        }</span>

        <span class="cov8" title="18">if port != "" </span><span class="cov8" title="18">{
                uport, err := strconv.Atoi(port)
                if err != nil </span><span class="cov2" title="2">{
                        return "", "", errors.Wrap(err, "Invalid port")
                }</span>
                <span class="cov8" title="16">if uport &lt;= 0 || uport &gt;= 65535 </span><span class="cov2" title="2">{
                        return "", "", errors.Errorf("Invalid port, out of range 0&lt;%s&lt;65535", port)
                }</span>
        }

        <span class="cov8" title="14">return ip, port, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "net"

        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

func validateSSLOptions() error <span class="cov10" title="10">{
        sslSpec := viper.GetString(KeySSLListen)

        ip, port, err := parseListen(sslSpec, "")
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov9" title="8">viper.Set(KeySSLListen, net.JoinHostPort(ip, port))

        sslCert := viper.GetString(KeySSLCertFile)
        sslKey := viper.GetString(KeySSLKeyFile)

        cert, err := verifyFile(sslCert)
        if err != nil </span><span class="cov6" title="4">{
                return errors.Wrapf(err, "SSL cert")
        }</span>

        <span class="cov6" title="4">key, err := verifyFile(sslKey)
        if err != nil </span><span class="cov3" title="2">{
                return errors.Wrapf(err, "SSL key")
        }</span>

        <span class="cov3" title="2">viper.Set(KeySSLCertFile, cert)
        viper.Set(KeySSLKeyFile, key)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "path/filepath"
        "regexp"
        "strconv"

        "github.com/circonus-labs/circonus-agent/internal/config/defaults"
        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

func validateStatsdOptions() error <span class="cov10" title="24">{
        if viper.GetBool(KeyStatsdDisabled) </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov9" title="23">port := viper.GetString(KeyStatsdPort)
        if port == "" </span><span class="cov1" title="1">{
                return errors.New("Invalid StatsD port (empty)")
        }</span>
        <span class="cov9" title="22">if ok, err := regexp.MatchString("^[0-9]+$", port); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Invalid StatsD port (%s)", port)
        }</span><span class="cov9" title="22"> else if !ok </span><span class="cov1" title="1">{
                return errors.Errorf("Invalid StatsD port (%s)", port)
        }</span>
        <span class="cov9" title="21">if pnum, err := strconv.ParseUint(port, 10, 32); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "Invalid StatsD port")
        }</span><span class="cov9" title="21"> else if pnum &lt; 1024 || pnum &gt; 65535 </span><span class="cov2" title="2">{
                return errors.Errorf("Invalid StatsD port 1024&gt;%s&lt;65535", port)
        }</span>

        // can be empty (all metrics go to host)
        // validate further if group check is enabled (see groupPrefix validation below)
        <span class="cov9" title="19">hostPrefix := viper.GetString(KeyStatsdHostPrefix)

        hostCat := viper.GetString(KeyStatsdHostCategory)
        if hostCat == "" </span><span class="cov1" title="1">{
                return errors.New("Invalid StatsD host category (empty)")
        }</span>

        <span class="cov9" title="18">groupCID := viper.GetString(KeyStatsdGroupCID)
        if groupCID == "" </span><span class="cov1" title="1">{
                return nil // statsd group check support disabled, all metrics go to host
        }</span>

        <span class="cov9" title="17">if groupCID == "cosi" </span><span class="cov1" title="1">{
                cfgFile := filepath.Join(defaults.BasePath, "..", cosiName, "registration", "registration-check-group.json")
                cid, err := loadCOSICheckID(cfgFile)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">groupCID = cid
                viper.Set(KeyStatsdGroupCID, groupCID)</span>
        }

        <span class="cov8" title="16">if err := validCheckID(groupCID); err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "StatsD Group Check ID")
        }</span>

        <span class="cov8" title="15">groupPrefix := viper.GetString(KeyStatsdGroupPrefix)
        if hostPrefix == "" &amp;&amp; groupPrefix == "" </span><span class="cov2" title="2">{
                return errors.New("StatsD host/group prefix mismatch (both empty)")
        }</span>

        <span class="cov8" title="13">if hostPrefix == groupPrefix </span><span class="cov1" title="1">{
                return errors.New("StatsD host/group prefix mismatch (same)")
        }</span>

        <span class="cov8" title="12">counterOp := viper.GetString(KeyStatsdGroupCounters)
        if counterOp == "" </span><span class="cov1" title="1">{
                return errors.New("Invalid StatsD counter operator (empty)")
        }</span>
        <span class="cov7" title="11">if ok, err := regexp.MatchString("^(average|sum)$", counterOp); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Invalid StatsD counter operator (%s)", counterOp)
        }</span><span class="cov7" title="11"> else if !ok </span><span class="cov1" title="1">{
                return errors.Errorf("Invalid StatsD counter operator (%s)", counterOp)
        }</span>

        <span class="cov7" title="10">gaugeOp := viper.GetString(KeyStatsdGroupGauges)
        if gaugeOp == "" </span><span class="cov4" title="3">{
                return errors.New("Invalid StatsD gauge operator (empty)")
        }</span>
        <span class="cov6" title="7">if ok, err := regexp.MatchString("^(average|sum)$", gaugeOp); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Invalid StatsD gauge operator (%s)", gaugeOp)
        }</span><span class="cov6" title="7"> else if !ok </span><span class="cov1" title="1">{
                return errors.Errorf("Invalid StatsD gauge operator (%s)", gaugeOp)
        }</span>

        <span class="cov6" title="6">setOp := viper.GetString(KeyStatsdGroupSets)
        if setOp == "" </span><span class="cov4" title="3">{
                return errors.New("Invalid StatsD set operator (empty)")
        }</span>
        <span class="cov4" title="3">if ok, err := regexp.MatchString("^(average|sum)$", setOp); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Invalid StatsD set operator (%s)", setOp)
        }</span><span class="cov4" title="3"> else if !ok </span><span class="cov1" title="1">{
                return errors.Errorf("Invalid StatsD set operator (%s)", setOp)
        }</span>

        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package config

import (
        "errors"
        "os"
        "path/filepath"
)

func verifyFile(fileName string) (string, error) <span class="cov10" title="12">{
        if fileName == "" </span><span class="cov4" title="3">{
                return "", errors.New("Invalid file name (empty)")
        }</span>

        <span class="cov8" title="9">var absFileName string
        var fi os.FileInfo
        var err error

        absFileName, err = filepath.Abs(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="9">fileName = absFileName

        fi, err = os.Stat(fileName)
        if os.IsNotExist(err) </span><span class="cov3" title="2">{
                return "", err
        }</span>

        <span class="cov8" title="7">if os.IsPermission(err) </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="7">if !fi.Mode().IsRegular() </span><span class="cov1" title="1">{
                return "", errors.New("not a regular file")
        }</span>

        // also try opening, to verify permissions
        // if last directory on path is not accessible to user, stat doesn't return EPERM
        <span class="cov7" title="6">f, err := os.Open(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="6">f.Close()

        return fileName, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package plugins

import (
        "context"
        "encoding/json"
        "strings"
        "sync"
        "time"

        // "github.com/rjeczalik/notify"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/maier/go-appstats"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

// New returns a new instance of the plugins manager
func New(ctx context.Context) *Plugins <span class="cov6" title="8">{
        p := Plugins{
                ctx:           ctx,
                generation:    0,
                running:       false,
                pluginDir:     viper.GetString(config.KeyPluginDir),
                logger:        log.With().Str("pkg", "plugins").Logger(),
                reservedNames: map[string]bool{"write": true, "statsd": true},
                active:        make(map[string]*plugin),
        }

        return &amp;p
}</span>

// Flush plugin metrics
func (p *Plugins) Flush(pluginName string) *map[string]interface{} <span class="cov2" title="2">{
        p.RLock()
        defer p.RUnlock()

        appstats.MapSet("plugins", "last_flush", time.Now())

        metrics := map[string]interface{}{}

        for pluginID, plug := range p.active </span><span class="cov8" title="18">{
                if pluginName == "" || // all plugins
                        pluginID == pluginName || // specific plugin
                        strings.HasPrefix(pluginID, pluginName+"`") </span><span class="cov1" title="1">{ // specific plugin with instances
                        metrics[pluginID] = plug.drain()
                }</span>
        }

        <span class="cov2" title="2">return &amp;metrics</span>
}

// Stop any long running plugins
func (p *Plugins) Stop() error <span class="cov6" title="7">{
        p.logger.Info().Msg("Stopping plugins")
        return nil

        // for id, plug := range p.active {
        //         plug.Lock()
        //         if !plug.Running {
        //                 plug.Unlock()
        //                 continue
        //         }
        //         if plug.cmd == nil {
        //                 plug.Unlock()
        //                 continue
        //         }
        //         if plug.cmd.Process != nil {
        //                 var stop bool
        //                 if plug.cmd.ProcessState == nil {
        //                         stop = true
        //                 } else {
        //                         stop = !plug.cmd.ProcessState.Exited()
        //                 }
        //
        //                 if stop {
        //                         p.logger.Info().
        //                                 Str("plugin", id).
        //                                 Msg("Stopping running plugin")
        //                         err := plug.cmd.Process.Kill()
        //                         if err != nil {
        //                                 p.logger.Error().
        //                                         Err(err).
        //                                         Str("plugin", id).
        //                                         Msg("Stopping plugin")
        //                         }
        //                 }
        //         }
        //         plug.Unlock()
        // }
        // return nil
}</span>

// Run one or all plugins
func (p *Plugins) Run(pluginName string) error <span class="cov5" title="5">{
        p.Lock()
        defer p.Unlock()

        if p.running </span><span class="cov1" title="1">{
                msg := "plugin run already in progress"
                p.logger.Info().Msg(msg)
                return errors.Errorf(msg)
        }</span>

        <span class="cov4" title="4">start := time.Now()
        appstats.MapSet("plugins", "last_run_start", start)

        p.running = true

        var wg sync.WaitGroup

        if pluginName != "" </span><span class="cov4" title="3">{
                numFound := 0
                for pluginID, plug := range p.active </span><span class="cov10" title="27">{
                        if pluginID == pluginName || // specific plugin
                                strings.HasPrefix(pluginID, pluginName+"`") </span><span class="cov2" title="2">{ // specific plugin with instances
                                numFound++
                                wg.Add(1)
                                go func(id string, plug *plugin) </span><span class="cov2" title="2">{
                                        plug.exec()
                                        wg.Done()
                                }</span>(pluginID, plug)
                        }
                }
                <span class="cov4" title="3">if numFound == 0 </span><span class="cov1" title="1">{
                        p.logger.Error().
                                Str("plugin", pluginName).
                                Msg("Invalid/Unknown")
                        p.running = false
                        return errors.Errorf("invalid plugin (%s)", pluginName)
                }</span>
        }<span class="cov1" title="1"> else {
                wg.Add(len(p.active))
                for pluginID, pluginRef := range p.active </span><span class="cov7" title="9">{
                        go func(id string, plug *plugin) </span><span class="cov7" title="9">{
                                plug.exec()
                                wg.Done()
                        }</span>(pluginID, pluginRef)
                }
        }

        <span class="cov4" title="3">wg.Wait()
        p.logger.Debug().Msg("all plugins done")

        appstats.MapSet("plugins", "last_run_end", time.Now())
        appstats.MapSet("plugins", "last_run_duration", time.Since(start))

        p.running = false

        return nil</span>
}

// IsValid determines if a specific plugin is valid
func (p *Plugins) IsValid(pluginName string) bool <span class="cov4" title="3">{
        if pluginName == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov2" title="2">p.RLock()
        defer p.RUnlock()

        for pluginID := range p.active </span><span class="cov8" title="17">{
                // specific plugin       plugin with instances
                if pluginID == pluginName || strings.HasPrefix(pluginID, pluginName+"`") </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

// IsInternal checks to see if the plugin is one of the internal plugins (write|statsd)
func (p *Plugins) IsInternal(pluginName string) bool <span class="cov4" title="4">{
        if pluginName == "" </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="3">_, reserved := p.reservedNames[pluginName]

        return reserved</span>
}

type lastRunError struct {
        Code int    `json:"code"`
        Msg  string `json:"message"`
}

type pluginDetails struct {
        Name            string   `json:"name"`
        Instance        string   `json:"instance"`
        Command         string   `json:"command"`
        Args            []string `json:"args"`
        LastRunStart    string   `json:"last_run_start"`
        LastRunDuration string   `json:"last_run_duration"`
        LastError       string   `json:"last_error"`
}

// Inventory returns list of active plugins
func (p *Plugins) Inventory() []byte <span class="cov1" title="1">{
        p.Lock()
        defer p.Unlock()
        inventory := make(map[string]*pluginDetails, len(p.active))
        for id, plug := range p.active </span><span class="cov7" title="9">{
                plug.Lock()
                inventory[id] = &amp;pluginDetails{
                        Name:            plug.ID,
                        Instance:        plug.InstanceID,
                        Command:         plug.Command,
                        Args:            plug.InstanceArgs,
                        LastRunStart:    plug.LastStart.Format(time.RFC3339Nano),
                        LastRunDuration: plug.LastRunDuration.String(),
                }

                if plug.LastError != nil </span><span class="cov6" title="8">{
                        inventory[id].LastError = plug.LastError.Error()
                }</span>

                <span class="cov7" title="9">plug.Unlock()</span>
        }
        <span class="cov1" title="1">data, err := json.Marshal(inventory)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Fatal().Err(err).Msg("inventory -&gt; json")
        }</span>
        <span class="cov1" title="1">return data</span>
}

// func pluginWatcher() {
//         c := make(chan notify.EventInfo, 1)
//
//         if err := notify.Watch(pluginDir, c, notify.All); err != nil {
//                 logger.Fatal().
//                         Err(err).
//                         Str("plugin-dir", pluginDir).
//                         Msg("Unable to watch plugin directory")
//         }
//
//         defer notify.Stop(c)
//
//         for ei := range c {
//                 logger.Debug().
//                         Str("event", ei.Event().String()).
//                         Str("path", ei.Path()).
//                         Msg("event")
//         }
// }
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package plugins

import (
        "bufio"
        "bytes"
        "encoding/json"
        "fmt"
        "os/exec"
        "regexp"
        "strconv"
        "strings"
        "time"

        cgm "github.com/circonus-labs/circonus-gometrics"
        "github.com/pkg/errors"
)

// drain returns and resets plugin's current metrics
func (p *plugin) drain() *cgm.Metrics <span class="cov3" title="3">{
        p.Lock()
        defer p.Unlock()

        var metrics *cgm.Metrics
        if p.metrics == nil </span><span class="cov2" title="2">{
                if p.prevMetrics == nil </span><span class="cov1" title="1">{
                        metrics = &amp;cgm.Metrics{}
                }</span><span class="cov1" title="1"> else {
                        metrics = p.prevMetrics
                }</span>
        }<span class="cov1" title="1"> else {
                metrics = p.metrics
                p.metrics = nil
                p.prevMetrics = metrics
        }</span>

        <span class="cov3" title="3">return metrics</span>
}

// parsePluginOutput handles json and tab delimited output from plugins.
func (p *plugin) parsePluginOutput(output []string) error <span class="cov9" title="53">{
        p.Lock()
        defer p.Unlock()

        p.logger.Debug().
                Str("output", strings.Join(output, "\n")).
                Msg("processing")

        if len(output) == 0 </span><span class="cov5" title="8">{
                p.metrics = &amp;cgm.Metrics{}
                return errors.Errorf("Zero lines of output")
        }</span>

        <span class="cov9" title="45">metrics := cgm.Metrics{}

        // if first char of first line is '{' then assume output is json
        if output[0][:1] == "{" </span><span class="cov2" title="2">{
                err := json.Unmarshal([]byte(strings.Join(output, "\n")), &amp;metrics)
                if err != nil </span><span class="cov1" title="1">{
                        p.logger.Error().
                                Err(err).
                                Str("output", strings.Join(output, "\n")).
                                Msg("parsing json")
                        p.metrics = &amp;cgm.Metrics{}
                        return errors.Wrap(err, "parsing json")
                }</span>
                <span class="cov1" title="1">p.metrics = &amp;metrics
                return nil</span>
        }

        // otherwise, assume it is delimited fields:
        //  fieldDelimiter is current TAB
        //  metric_name&lt;TAB&gt;metric_type[&lt;TAB&gt;metric_value]
        //  foo\ti\t10  - int32 foo w/value 10
        //  bar\tL      - uint64 bar w/o value (null, metric is present but has no value)
        <span class="cov8" title="43">metricTypes := regexp.MustCompile("^[iIlLnOs]$")
        for _, line := range output </span><span class="cov8" title="43">{
                delimCount := strings.Count(line, fieldDelimiter)
                if delimCount == 0 </span><span class="cov1" title="1">{
                        p.logger.Error().
                                Str("line", line).
                                Msg("invalid format, zero field delimiters found")
                        continue</span>
                }

                <span class="cov8" title="42">fields := strings.Split(line, fieldDelimiter)
                if len(fields) &lt;= 1 || len(fields) &gt; 3 </span><span class="cov1" title="1">{
                        p.logger.Error().
                                Str("line", line).
                                Int("fields", len(fields)).
                                Int("delimiters", delimCount).
                                Msg("invalid number of fields, expect 2 or 3")
                        continue</span>
                }

                <span class="cov8" title="41">metricName := strings.Replace(fields[0], " ", metricDelimiter, -1)
                metricType := fields[1]

                if !metricTypes.MatchString(metricType) </span><span class="cov3" title="3">{
                        p.logger.Error().
                                Str("line", line).
                                Str("type", metricType).
                                Msg("invalid metric type")
                        continue</span>
                }

                // only received a name and type (intentionally null value)
                <span class="cov8" title="38">if len(fields) == 2 </span><span class="cov1" title="1">{
                        metrics[metricName] = cgm.Metric{
                                Type:  metricType,
                                Value: nullMetricValue,
                        }
                        continue</span>
                }

                <span class="cov8" title="37">metricValue := fields[2]

                // intentionally null value, explicit syntax
                if strings.ToLower(metricValue) == nullMetricValue </span><span class="cov1" title="1">{
                        metrics[metricName] = cgm.Metric{
                                Type:  metricType,
                                Value: nullMetricValue,
                        }
                        continue</span>
                }

                <span class="cov8" title="36">metric := cgm.Metric{}

                switch metricType </span>{
                case "i":<span class="cov2" title="2"> // signed 32bit
                        metric.Type = metricType
                        i, err := strconv.ParseInt(metricValue, 10, 32)
                        if err != nil </span><span class="cov1" title="1">{
                                p.logger.Error().
                                        Err(err).
                                        Str("line", line).
                                        Msg("unable to parse int32")
                                continue</span>
                        }
                        <span class="cov1" title="1">metric.Value = int32(i)</span>
                case "I":<span class="cov2" title="2"> // unsigned 32bit
                        metric.Type = metricType
                        u, err := strconv.ParseUint(metricValue, 10, 32)
                        if err != nil </span><span class="cov1" title="1">{
                                p.logger.Error().
                                        Err(err).
                                        Str("line", line).
                                        Msg("unable to parse uint32")
                                continue</span>
                        }
                        <span class="cov1" title="1">metric.Value = uint32(u)</span>
                case "l":<span class="cov2" title="2"> // signed 64bit
                        metric.Type = metricType
                        i, err := strconv.ParseInt(metricValue, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                p.logger.Error().
                                        Err(err).
                                        Str("line", line).
                                        Msg("unable to parse int64")
                                continue</span>
                        }
                        <span class="cov1" title="1">metric.Value = i</span>
                case "L":<span class="cov2" title="2"> // unsigned 64bit
                        metric.Type = metricType
                        u, err := strconv.ParseUint(metricValue, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                p.logger.Error().
                                        Err(err).
                                        Str("line", line).
                                        Msg("unable to parse uint64")
                                continue</span>
                        }
                        <span class="cov1" title="1">metric.Value = u</span>
                case "n":<span class="cov7" title="26"> // double
                        metric.Type = metricType
                        f, err := strconv.ParseFloat(metricValue, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                p.logger.Error().
                                        Err(err).
                                        Str("line", line).
                                        Msg("unable to parse double/float")
                                continue</span>
                        }
                        <span class="cov7" title="25">metric.Value = f</span>
                case "s":<span class="cov1" title="1"> // string
                        metric.Type = metricType
                        metric.Value = metricValue</span>
                case "O":<span class="cov1" title="1"> // have Circonus automatically detect
                        metric.Type = metricType
                        metric.Value = metricValue</span>
                default:<span class="cov0" title="0">
                        p.logger.Error().
                                Str("line", line).
                                Str("type", metricType).
                                Msg("unknown metric type")
                        continue</span>
                }

                <span class="cov8" title="31">metrics[metricName] = metric</span>

        }

        <span class="cov8" title="43">p.metrics = &amp;metrics

        return nil</span>
}

// exec runs a specific plugin and saves plugin output
func (p *plugin) exec() error <span class="cov10" title="70">{
        // NOTE: !! IMPORTANT !!
        //       locks are handled manually so that long running plugins
        //       do not block access to plugin meta data and metrics
        p.Lock()

        plog := p.logger

        plog.Debug().Msg("Running")

        if p.Running </span><span class="cov1" title="1">{
                msg := "already running"
                plog.Info().Msg(msg)
                p.Unlock()
                return errors.New(msg)
        }</span>

        <span class="cov9" title="69">p.Running = true
        p.LastStart = time.Now()
        p.cmd = exec.CommandContext(p.ctx, p.Command)
        p.cmd.Dir = p.RunDir
        if p.InstanceArgs != nil </span><span class="cov6" title="15">{
                p.cmd.Args = append(p.cmd.Args, p.InstanceArgs...)
        }</span>

        <span class="cov9" title="69">var errOut bytes.Buffer
        p.cmd.Stderr = &amp;errOut

        p.Unlock()

        resetStatus := func(err error) </span><span class="cov9" title="69">{
                p.Lock()
                p.LastRunDuration = time.Since(p.LastStart)
                p.LastError = err
                p.Running = false
                p.Unlock()
        }</span>

        <span class="cov9" title="69">stdout, err := p.cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                msg := "stdout pipe"
                plog.Error().
                        Err(err).
                        Msg(msg)
                resetStatus(err)
                return errors.Wrap(err, msg)
        }</span>

        <span class="cov9" title="69">lines := []string{}
        scanner := bufio.NewScanner(stdout)

        if err := p.cmd.Start(); err != nil </span><span class="cov8" title="38">{
                msg := "cmd start"
                plog.Error().
                        Err(err).
                        Str("cmd", p.Command).
                        Msg(msg)
                resetStatus(err)
                return errors.Wrap(err, msg)
        }</span>

        <span class="cov8" title="31">for scanner.Scan() </span><span class="cov7" title="24">{
                line := scanner.Text()

                // blank line, long running plugin signal to parse
                // what has already been received.
                if line == "" </span><span class="cov0" title="0">{
                        p.parsePluginOutput(lines)
                        lines = []string{}
                        continue</span>
                }

                // add line to buffer for processing
                <span class="cov7" title="24">lines = append(lines, line)</span>
        }

        <span class="cov8" title="31">var runErr error

        if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                plog.Error().
                        Err(err).
                        Msg("reading stdio")

                runErr = errors.Wrap(err, "scanner, reading stdio")
        }</span>

        // parse lines if there are any in the buffer
        // or, in case of long running plugin, any left in buffer on exit
        <span class="cov8" title="31">p.parsePluginOutput(lines)

        if err := p.cmd.Wait(); err != nil </span><span class="cov3" title="4">{
                var stderr string
                if errOut.Len() &gt; 0 </span><span class="cov3" title="4">{
                        stderr = strings.Replace(errOut.String(), "\n", "", -1)
                }</span>
                <span class="cov3" title="4">if exiterr, ok := err.(*exec.ExitError); ok </span><span class="cov3" title="4">{
                        errMsg := fmt.Sprintf("%s %s", stderr, exiterr.Stderr)
                        plog.Error().
                                Str("stderr", errMsg).
                                Str("status", exiterr.String()).
                                Str("cmd", p.Command).
                                Msg("exited non-zero")
                        if runErr != nil </span><span class="cov0" title="0">{
                                runErr = errors.Wrapf(exiterr, "cmd err (%s) and %s", errMsg, runErr)
                        }</span><span class="cov3" title="4"> else {
                                runErr = errors.Wrapf(exiterr, "cmd err (%s)", errMsg)
                        }</span>
                }<span class="cov0" title="0"> else {
                        plog.Error().
                                Err(err).
                                Str("cmd", p.Command).
                                Str("stderr", stderr).
                                Msg("exited non-zero (not exiterr)")
                        if runErr != nil </span><span class="cov0" title="0">{
                                runErr = errors.Wrapf(err, "cmd err (%s) and %s", stderr, runErr)
                        }</span><span class="cov0" title="0"> else {
                                runErr = errors.Wrapf(err, "cmd err (%s)", stderr)
                        }</span>
                }
        }

        <span class="cov8" title="31">resetStatus(runErr)
        return runErr</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package plugins

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/maier/go-appstats"
        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

// Scan the plugin directory for new/updated plugins
func (p *Plugins) Scan() error <span class="cov4" title="7">{
        p.Lock()
        defer p.Unlock()

        // initialRun fires each plugin one time. Unlike 'Run' it does
        // not wait for plugins to finish this will provides:
        //
        // 1. an initial seeding of results
        // 2. starts any long running plugins without blocking
        //
        initialRun := func() error </span><span class="cov4" title="6">{
                for id, plug := range p.active </span><span class="cov8" title="54">{
                        p.logger.Debug().
                                Str("plugin", id).
                                Msg("Initializing")
                        go plug.exec()
                }</span>
                <span class="cov4" title="6">return nil</span>
        }

        <span class="cov4" title="7">if err := p.Stop(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "stopping plugin(s)")
        }</span>

        // appstats.MapSet("plugins", "total", bytes.NewBufferString("0"))

        <span class="cov4" title="7">if err := p.scanPluginDirectory(); err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "plugin directory scan")
        }</span>

        <span class="cov4" title="6">if err := initialRun(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "initializing plugin(s)")
        }</span>

        <span class="cov4" title="6">return nil</span>
}

// scanPluginDirectory finds and loads plugins
func (p *Plugins) scanPluginDirectory() error <span class="cov5" title="10">{
        p.generation++

        pluginDir := viper.GetString(config.KeyPluginDir)

        if pluginDir == "" </span><span class="cov2" title="2">{
                return errors.New("invalid plugin directory (none)")
        }</span>

        <span class="cov4" title="8">p.logger.Info().
                Str("dir", pluginDir).
                Msg("Scanning plugin directory")

        f, err := os.Open(pluginDir)
        if err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "open plugin directory")
        }</span>

        <span class="cov4" title="7">defer f.Close()

        files, err := f.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "reading plugin directory")
        }</span>

        <span class="cov4" title="7">for _, fi := range files </span><span class="cov10" title="140">{
                fileName := fi.Name()

                p.logger.Debug().
                        Str("path", filepath.Join(pluginDir, fileName)).
                        Msg("checking plugin directory entry")

                if fi.IsDir() </span><span class="cov6" title="21">{
                        p.logger.Debug().
                                Str("file", fileName).
                                Msg("directory, ignoring")
                        continue</span>
                }

                <span class="cov9" title="119">fileBase := fileName
                fileExt := filepath.Ext(fileName)

                if fileExt != "" </span><span class="cov9" title="112">{
                        fileBase = strings.Replace(fileName, fileExt, "", -1)
                }</span>

                <span class="cov9" title="119">if fileBase == "" || fileExt == "" </span><span class="cov4" title="7">{
                        p.logger.Debug().
                                Str("file", fileName).
                                Msg("invalid file name format, ignoring")
                        continue</span>
                }

                <span class="cov9" title="112">if fileExt == ".conf" || fileExt == ".json" </span><span class="cov7" title="35">{
                        p.logger.Debug().
                                Str("file", fileName).
                                Msg("config file, ignoring")
                        continue</span>
                }

                <span class="cov8" title="77">if _, reserved := p.reservedNames[fileBase]; reserved </span><span class="cov4" title="7">{
                        p.logger.Warn().
                                Str("file", fileName).
                                Msg("reserved plugin name, ignoring")
                        continue</span>
                }

                <span class="cov8" title="70">var cmdName string

                switch mode := fi.Mode(); </span>{
                case mode.IsRegular():<span class="cov8" title="56">
                        cmdName = filepath.Join(pluginDir, fi.Name())</span>
                case mode&amp;os.ModeSymlink != 0:<span class="cov5" title="14">
                        resolvedSymlink, err := filepath.EvalSymlinks(filepath.Join(pluginDir, fi.Name()))
                        if err != nil </span><span class="cov4" title="7">{
                                p.logger.Warn().
                                        Err(err).
                                        Str("file", fi.Name()).
                                        Msg("Error resolving symlink, ignoring")
                                continue</span>
                        }
                        <span class="cov4" title="7">cmdName = resolvedSymlink</span>
                default:<span class="cov0" title="0">
                        p.logger.Debug().
                                Str("file", fileName).
                                Msg("not a regular file or symlink, ignoring")
                        continue</span> // just ignore it
                }

                <span class="cov8" title="63">if perm := fi.Mode().Perm() &amp; 0111; perm != 73 </span><span class="cov4" title="7">{
                        p.logger.Warn().
                                Str("file", cmdName).
                                Str("perms", fmt.Sprintf("%q", fi.Mode().Perm())).
                                Msg("executable bit not set, ignoring")
                        continue</span>
                }

                <span class="cov8" title="56">var cfg map[string][]string

                // check for config file
                cfgFile := filepath.Join(pluginDir, fmt.Sprintf("%s.json", fileBase))
                if data, err := ioutil.ReadFile(cfgFile); err != nil </span><span class="cov7" title="42">{
                        if !os.IsNotExist(err) </span><span class="cov4" title="7">{
                                p.logger.Warn().
                                        Err(err).
                                        Str("config", cfgFile).
                                        Str("plugin", fileBase).Msg("plugin config")
                        }</span>
                }<span class="cov5" title="14"> else {
                        if len(data) &gt; 0 </span><span class="cov5" title="14">{
                                err := json.Unmarshal(data, &amp;cfg)
                                if err != nil </span><span class="cov4" title="7">{
                                        p.logger.Warn().
                                                Err(err).
                                                Str("config", cfgFile).
                                                Str("plugin", fileBase).
                                                Str("data", string(data)).
                                                Msg("parsing config")
                                }</span>

                                <span class="cov5" title="14">p.logger.Debug().
                                        Str("config", fmt.Sprintf("%+v", cfg)).
                                        Msg("loaded plugin config")</span>
                        }
                }

                <span class="cov8" title="56">if cfg == nil </span><span class="cov8" title="49">{
                        plug, ok := p.active[fileBase]
                        if !ok </span><span class="cov8" title="49">{
                                p.active[fileBase] = &amp;plugin{
                                        ctx:    p.ctx,
                                        ID:     fileBase,
                                        Name:   fileBase,
                                        logger: p.logger.With().Str("plugin", fileBase).Logger(),
                                        RunDir: p.pluginDir,
                                }
                                plug = p.active[fileBase]
                        }</span>

                        <span class="cov8" title="49">appstats.MapIncrementInt("plugins", "total")
                        plug.Generation = p.generation
                        plug.Command = cmdName
                        p.logger.Info().
                                Str("id", fileBase).
                                Str("cmd", cmdName).
                                Uint64("generation", p.generation).
                                Msg("Activating plugin")</span>

                }<span class="cov4" title="7"> else {
                        for inst, args := range cfg </span><span class="cov5" title="14">{
                                pluginName := fmt.Sprintf("%s`%s", fileBase, inst)
                                plug, ok := p.active[pluginName]
                                if !ok </span><span class="cov5" title="14">{
                                        p.active[pluginName] = &amp;plugin{
                                                ctx:          p.ctx,
                                                ID:           fileBase,
                                                InstanceID:   inst,
                                                InstanceArgs: args,
                                                Name:         pluginName,
                                                logger:       p.logger.With().Str("plugin", pluginName).Logger(),
                                                RunDir:       p.pluginDir,
                                        }
                                        plug = p.active[pluginName]
                                }</span>

                                <span class="cov5" title="14">appstats.MapIncrementInt("plugins", "total")
                                plug.Generation = p.generation
                                plug.Command = cmdName
                                p.logger.Info().
                                        Str("id", pluginName).
                                        Str("cmd", cmdName).
                                        Uint64("generation", p.generation).
                                        Msg("Activating plugin")</span>

                        }
                }
        }

        // only relevant if *watching* is implemented
        // // purge inactive plugins (plugins removed from plugin directory)
        // for id, plug := range p.active {
        //         if plug.Generation != p.generation {
        //                 p.logger.Debug().
        //                         Str("plugin", id).
        //                         Msg("purging inactive plugin")
        //                 delete(p.active, id)
        //         }
        // }

        <span class="cov4" title="7">if len(p.active) == 0 </span><span class="cov0" title="0">{
                return errors.New("No active plugins found")
        }</span>

        <span class="cov4" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package release

import (
        "expvar"
)

func init() <span class="cov8" title="1">{
        expvar.Publish("app", expvar.Func(info))
}</span>

func info() interface{} <span class="cov8" title="1">{
        return &amp;Info{
                Name:      NAME,
                Version:   VERSION,
                Commit:    COMMIT,
                BuildDate: DATE,
                Tag:       TAG,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package reverse

import (
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "io/ioutil"
        stdlog "log"
        "math/rand"
        "net"
        "net/url"
        "reflect"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/circonus-labs/circonus-gometrics/api"
        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

func (c *Connection) getTLSConfig(cid string, reverseURL *url.URL) (*tls.Config, error) <span class="cov10" title="9">{
        if cid == "" </span><span class="cov1" title="1">{
                return nil, errors.New("No broker CID supplied")
        }</span>
        <span class="cov9" title="8">if ok, _ := regexp.MatchString("^/broker/[0-9]+$", cid); !ok </span><span class="cov1" title="1">{
                return nil, errors.Errorf("Invalid broker CID (%s)", cid)
        }</span>

        <span class="cov8" title="7">cfg := &amp;api.Config{
                TokenKey: viper.GetString(config.KeyAPITokenKey),
                TokenApp: viper.GetString(config.KeyAPITokenApp),
                URL:      viper.GetString(config.KeyAPIURL),
                Log:      stdlog.New(c.logger.With().Str("pkg", "circonus-gometrics.api").Logger(), "", 0),
                Debug:    viper.GetBool(config.KeyDebugCGM),
        }

        client, err := api.New(cfg)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.Wrap(err, "Initializing cgm API")
        }</span>

        <span class="cov8" title="6">broker, err := client.FetchBroker(api.CIDType(&amp;cid))
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.Wrapf(err, "Fetching broker (%s) from API", cid)
        }</span>

        <span class="cov7" title="5">cn, err := c.getBrokerCN(broker, reverseURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="4">cert, err := c.fetchBrokerCA(client)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="3">cp := x509.NewCertPool()
        if !cp.AppendCertsFromPEM(cert) </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to add Broker CA Certificate to x509 cert pool")
        }</span>

        <span class="cov5" title="3">tlsConfig := &amp;tls.Config{
                RootCAs:    cp,
                ServerName: cn,
        }

        c.logger.Debug().Str("CN", cn).Msg("setting tls CN")

        return tlsConfig, nil</span>
}

func (c *Connection) getBrokerCN(broker *api.Broker, reverseURL *url.URL) (string, error) <span class="cov7" title="5">{
        host := reverseURL.Hostname()

        // OK...
        //
        // mtev_reverse can have an IP or an FQDN for the host portion
        // it used to be that when it was an IP, the CN was needed in order to verify TLS connections
        // otherwise, the FQDN was valid. now, the FQDN may be valid for the cert or it may not be...

        cn := ""

        for _, detail := range broker.Details </span><span class="cov7" title="5">{
                // certs are generated against the CN (in theory)
                // 1. find the right broker instance with matching IP or external hostname
                // 2. set the tls.Config.ServerName to whatever that instance's CN is currently
                // 3. cert will be valid for TLS conns (in theory)
                if detail.IP != nil &amp;&amp; *detail.IP == host </span><span class="cov6" title="4">{
                        cn = detail.CN
                        break</span>
                }
                <span class="cov1" title="1">if detail.ExternalHost != nil &amp;&amp; *detail.ExternalHost == host </span><span class="cov0" title="0">{
                        cn = detail.CN
                        break</span>
                }
        }

        <span class="cov7" title="5">if cn == "" </span><span class="cov1" title="1">{
                return "", errors.Errorf("Unable to match reverse URL host (%s) to broker", host)
        }</span>

        <span class="cov6" title="4">return cn, nil</span>
}

func (c *Connection) fetchBrokerCA(client *api.API) ([]byte, error) <span class="cov6" title="4">{
        // use local file if specified
        file := viper.GetString(config.KeyReverseBrokerCAFile)
        if file != "" </span><span class="cov3" title="2">{
                cert, err := ioutil.ReadFile(file)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, errors.Wrapf(err, "Reading specified broker-ca-file (%s)", file)
                }</span>
                <span class="cov1" title="1">return cert, nil</span>
        }

        // otherwise, try the api
        <span class="cov3" title="2">data, err := client.Get("/pki/ca.crt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Fetching Broker CA certificate")
        }</span>

        <span class="cov3" title="2">type cacert struct {
                Contents string `json:"contents"`
        }

        var cadata cacert

        if err := json.Unmarshal(data, &amp;cadata); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Parsing Broker CA certificate")
        }</span>

        <span class="cov3" title="2">if cadata.Contents == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("No Broker CA certificate in response (%#v)", string(data))
        }</span>

        <span class="cov3" title="2">return []byte(cadata.Contents), nil</span>
}

// Select a broker for use when creating a check, if a specific broker
// was not specified.
func (c *Connection) selectBroker(client *api.API, checkType string) (*api.Broker, error) <span class="cov0" title="0">{
        brokerList, err := client.FetchBrokers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "select broker")
        }</span>

        <span class="cov0" title="0">if len(*brokerList) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("zero brokers found")
        }</span>

        <span class="cov0" title="0">validBrokers := make(map[string]api.Broker)
        haveEnterprise := false

        for _, broker := range *brokerList </span><span class="cov0" title="0">{
                broker := broker
                if c.isValidBroker(&amp;broker, checkType) </span><span class="cov0" title="0">{
                        validBrokers[broker.CID] = broker
                        if broker.Type == "enterprise" </span><span class="cov0" title="0">{
                                haveEnterprise = true
                        }</span>
                }
        }

        <span class="cov0" title="0">if haveEnterprise </span><span class="cov0" title="0">{ // eliminate non-enterprise brokers from valid brokers
                for k, v := range validBrokers </span><span class="cov0" title="0">{
                        if v.Type != "enterprise" </span><span class="cov0" title="0">{
                                delete(validBrokers, k)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(validBrokers) == 0 </span><span class="cov0" title="0">{
                return nil, errors.Errorf("found %d broker(s), zero are valid", len(*brokerList))
        }</span>

        <span class="cov0" title="0">validBrokerKeys := reflect.ValueOf(validBrokers).MapKeys()
        selectedBroker := validBrokers[validBrokerKeys[rand.Intn(len(validBrokerKeys))].String()]

        c.logger.Debug().Str("broker", selectedBroker.Name).Msg("selected")

        return &amp;selectedBroker, nil</span>
}

// Is the broker valid (active, supports check type, and reachable)
func (c *Connection) isValidBroker(broker *api.Broker, checkType string) bool <span class="cov0" title="0">{
        var brokerHost string
        var brokerPort string
        valid := false
        for _, detail := range broker.Details </span><span class="cov0" title="0">{
                detail := detail

                // broker must be active
                if detail.Status != brokerActiveStatus </span><span class="cov0" title="0">{
                        c.logger.Debug().Str("broker", broker.Name).Msg("not active, skipping")
                        continue</span>
                }

                // broker must have module loaded for the check type to be used
                <span class="cov0" title="0">if !c.brokerSupportsCheckType(checkType, &amp;detail) </span><span class="cov0" title="0">{
                        c.logger.Debug().Str("broker", broker.Name).Str("type", checkType).Msg("unsupported check type, skipping")
                        continue</span>
                }

                <span class="cov0" title="0">if detail.ExternalPort != 0 </span><span class="cov0" title="0">{
                        brokerPort = strconv.Itoa(int(detail.ExternalPort))
                }</span><span class="cov0" title="0"> else {
                        if *detail.Port != 0 </span><span class="cov0" title="0">{
                                brokerPort = strconv.Itoa(int(*detail.Port))
                        }</span><span class="cov0" title="0"> else {
                                brokerPort = "43191"
                        }</span>
                }

                <span class="cov0" title="0">if detail.ExternalHost != nil &amp;&amp; *detail.ExternalHost != "" </span><span class="cov0" title="0">{
                        brokerHost = *detail.ExternalHost
                }</span><span class="cov0" title="0"> else {
                        brokerHost = *detail.IP
                }</span>

                <span class="cov0" title="0">if brokerHost == "trap.noit.circonus.net" &amp;&amp; brokerPort != "443" </span><span class="cov0" title="0">{
                        brokerPort = "443"
                }</span>

                <span class="cov0" title="0">minDelay := int(200 * time.Millisecond)
                maxDelay := int(2 * time.Second)

                for attempt := 1; attempt &lt;= brokerMaxRetries; attempt++ </span><span class="cov0" title="0">{
                        // broker must be reachable and respond within designated time
                        conn, err := net.DialTimeout("tcp", net.JoinHostPort(brokerHost, brokerPort), brokerMaxResponseTime)
                        if err == nil </span><span class="cov0" title="0">{
                                conn.Close()
                                valid = true
                                break</span>
                        }

                        <span class="cov0" title="0">delay := time.Duration(rand.Intn(maxDelay-minDelay) + minDelay)

                        c.logger.Warn().
                                Err(err).
                                Str("delay", delay.String()).
                                Str("broker", broker.Name).
                                Int("attempt", attempt).
                                Int("retries", brokerMaxRetries).
                                Msg("unable to connect, retrying")

                        time.Sleep(delay)</span>
                }

                <span class="cov0" title="0">if valid </span><span class="cov0" title="0">{
                        c.logger.Debug().Str("broker", broker.Name).Msg("valid")
                        break</span>
                }
        }
        <span class="cov0" title="0">return valid</span>
}

// Verify broker supports the check type to be used
func (c *Connection) brokerSupportsCheckType(checkType string, details *api.BrokerDetail) bool <span class="cov0" title="0">{
        baseType := string(checkType)

        for _, module := range details.Modules </span><span class="cov0" title="0">{
                if module == baseType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if idx := strings.Index(baseType, ":"); idx &gt; 0 </span><span class="cov0" title="0">{
                baseType = baseType[0:idx]
        }</span>

        <span class="cov0" title="0">for _, module := range details.Modules </span><span class="cov0" title="0">{
                if module == baseType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package reverse

import (
        "fmt"
        stdlog "log"
        "net/url"
        "regexp"
        "strings"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/circonus-labs/circonus-gometrics/api"
        apiconf "github.com/circonus-labs/circonus-gometrics/api/config"
        "github.com/pkg/errors"
        "github.com/spf13/viper"
)

func (c *Connection) setCheckConfig() error <span class="cov4" title="2">{
        bid, reverseURL, err := c.getCheckConfig()
        if err != nil </span><span class="cov1" title="1">{
                return errors.Wrap(err, "reverse configuration (check)")
        }</span>

        <span class="cov1" title="1">tlsConfig, err := c.getTLSConfig(bid, reverseURL)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "reverse configuration (tls)")
        }</span>

        <span class="cov1" title="1">c.reverseURL = reverseURL
        c.tlsConfig = tlsConfig

        return nil</span>
}

func (c *Connection) getCheckConfig() (string, *url.URL, error) <span class="cov10" title="8">{
        cfg := &amp;api.Config{
                TokenKey: viper.GetString(config.KeyAPITokenKey),
                TokenApp: viper.GetString(config.KeyAPITokenApp),
                URL:      viper.GetString(config.KeyAPIURL),
                Log:      stdlog.New(c.logger.With().Str("pkg", "circonus-gometrics.api").Logger(), "", 0),
                Debug:    viper.GetBool(config.KeyDebugCGM),
        }

        client, err := api.New(cfg)
        if err != nil </span><span class="cov4" title="2">{
                return "", nil, errors.Wrap(err, "Initializing cgm API")
        }</span>

        <span class="cov8" title="6">bundle, err := c.getCheckBundle(client)
        if err != nil </span><span class="cov5" title="3">{
                return "", nil, err
        }</span>

        <span class="cov5" title="3">if len(bundle.ReverseConnectURLs) == 0 </span><span class="cov0" title="0">{
                return "", nil, errors.New("No reverse URLs found in check")
        }</span>
        <span class="cov5" title="3">rURL := bundle.ReverseConnectURLs[0]
        rSecret := bundle.Config["reverse:secret_key"]

        if rSecret != "" </span><span class="cov5" title="3">{
                rURL += "#" + rSecret
        }</span>

        // Replace protocol, url.Parse does not understand 'mtev_reverse'.
        // Important part is validating what's after 'proto://'.
        // Using raw tls connections, the url protocol is not germane.
        <span class="cov5" title="3">reverseURL, err := url.Parse(strings.Replace(rURL, "mtev_reverse", "http", -1))
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, errors.Wrapf(err, "Unable to parse reverse URL (%s)", rURL)
        }</span>

        <span class="cov5" title="3">if len(bundle.Brokers) == 0 </span><span class="cov0" title="0">{
                return "", nil, errors.New("No brokers found in check")
        }</span>
        <span class="cov5" title="3">brokerID := bundle.Brokers[0]

        return brokerID, reverseURL, nil</span>
}

func (c *Connection) getCheckBundle(client *api.API) (*api.CheckBundle, error) <span class="cov8" title="6">{
        var (
                bundle *api.CheckBundle
                err    error
        )

        if c.checkCID != "" </span><span class="cov5" title="3">{
                // Retrieve check bundle if we have a CID
                if ok, _ := regexp.MatchString(`^[0-9]+$`, c.checkCID); ok </span><span class="cov4" title="2">{
                        c.checkCID = "/check_bundle/" + c.checkCID
                }</span>
                <span class="cov5" title="3">bundle, err = client.FetchCheckBundle(api.CIDType(&amp;c.checkCID))
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }<span class="cov5" title="3"> else {
                // Otherwise, search for a check bundle (optionally, create one if not found)
                bundle, err = c.searchForCheckBundle(client)
                if err != nil </span><span class="cov4" title="2">{
                        return nil, err
                }</span>
        }

        <span class="cov5" title="3">if bundle == nil </span><span class="cov0" title="0">{
                return nil, errors.New("No available check bundle to use for reverse")
        }</span>

        <span class="cov5" title="3">if bundle.CID != c.checkCID </span><span class="cov1" title="1">{
                c.checkCID = bundle.CID
        }</span>

        <span class="cov5" title="3">return bundle, nil</span>
}

func (c *Connection) searchForCheckBundle(client *api.API) (*api.CheckBundle, error) <span class="cov5" title="3">{
        criteria := api.SearchQueryType(fmt.Sprintf(`(active:1)(type:"json:nad")(target:"%s")`, viper.GetString(config.KeyReverseTarget)))
        bundles, err := client.SearchCheckBundles(&amp;criteria, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Searching for check bundles")
        }</span>

        <span class="cov5" title="3">if len(*bundles) == 0 </span><span class="cov1" title="1">{
                if !viper.GetBool(config.KeyReverseCreateCheck) </span><span class="cov1" title="1">{
                        return nil, errors.Errorf("No check bundles matched criteria (%s)", string(criteria))
                }</span>

                <span class="cov0" title="0">bundle, err := c.createCheckBundle(client)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return bundle, nil</span>
        }

        <span class="cov4" title="2">if len(*bundles) &gt; 1 </span><span class="cov1" title="1">{
                return nil, errors.Errorf("More than one (%d) check bundle matched criteria (%s)", len(*bundles), string(criteria))
        }</span>

        <span class="cov1" title="1">bundle := (*bundles)[0]

        return &amp;bundle, nil</span>
}

func (c *Connection) createCheckBundle(client *api.API) (*api.CheckBundle, error) <span class="cov0" title="0">{

        addr := c.agentAddress
        if addr[0:1] == ":" </span><span class="cov0" title="0">{
                addr = "localhost" + addr
        }</span>
        <span class="cov0" title="0">cfg := api.NewCheckBundle()
        cfg.DisplayName = viper.GetString(config.KeyReverseCreateCheckTitle)
        cfg.Target = viper.GetString(config.KeyReverseTarget)
        cfg.Type = "json:nad"
        cfg.Config = api.CheckBundleConfig{apiconf.URL: "http://" + addr + "/"}
        cfg.Metrics = []api.CheckBundleMetric{
                api.CheckBundleMetric{Name: "placeholder", Type: "text", Status: "active"}, // one metric is required again
        }

        tags := viper.GetString(config.KeyReverseCreateCheckTags)
        if tags != "" </span><span class="cov0" title="0">{
                cfg.Tags = strings.Split(tags, ",")
        }</span>

        <span class="cov0" title="0">brokerCID := viper.GetString(config.KeyReverseCreateCheckBroker)
        if brokerCID == "" || strings.ToLower(brokerCID) == "select" </span><span class="cov0" title="0">{
                broker, err := c.selectBroker(client, "json:nad")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">brokerCID = broker.CID</span>
        }

        <span class="cov0" title="0">if ok, _ := regexp.MatchString(`^[0-9]+$`, brokerCID); ok </span><span class="cov0" title="0">{
                brokerCID = "/broker/" + brokerCID
        }</span>

        <span class="cov0" title="0">cfg.Brokers = []string{brokerCID}

        bundle, err := client.CreateCheckBundle(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "creating check bundle")
        }</span>

        <span class="cov0" title="0">return bundle, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package reverse

import (
        "encoding/binary"
        "fmt"
        "io"
        "time"

        "github.com/pkg/errors"
)

// getCommandFromBroker reads a command and optional request from broker
func (c *Connection) getCommandFromBroker(r io.Reader) (*noitCommand, error) <span class="cov5" title="5">{
        if c.shutdown() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov5" title="5">cmdPkt, err := c.getFrameFromBroker(r)
        if c.shutdown() </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov4" title="4">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="4">if !cmdPkt.header.isCommand </span><span class="cov1" title="1">{
                c.logger.Warn().
                        Str("cmd_header", fmt.Sprintf("%#v", cmdPkt.header)).
                        Str("cmd_payload", string(cmdPkt.payload)).
                        Msg("expected command")
                return nil, nil
        }</span>

        <span class="cov4" title="3">nc := &amp;noitCommand{
                channelID: cmdPkt.header.channelID,
                command:   string(cmdPkt.payload),
        }

        if nc.command == noitCmdConnect </span><span class="cov4" title="3">{ // connect command requires a request
                reqPkt, err := c.getFrameFromBroker(r)
                if c.shutdown() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov4" title="3">if reqPkt.header.isCommand </span><span class="cov1" title="1">{
                        c.logger.Warn().
                                Str("cmd_header", fmt.Sprintf("%#v", cmdPkt.header)).
                                Str("cmd_payload", string(cmdPkt.payload)).
                                Str("req_header", fmt.Sprintf("%#v", reqPkt.header)).
                                Str("req_payload", string(reqPkt.payload)).
                                Msg("expected request")
                        return nil, nil
                }</span>

                <span class="cov2" title="2">nc.request = reqPkt.payload</span>
        }

        <span class="cov2" title="2">return nc, nil</span>
}

// getFrameFromBroker reads a frame(header + payload) from broker
func (c *Connection) getFrameFromBroker(r io.Reader) (*noitPacket, error) <span class="cov7" title="10">{
        if c.conn != nil </span><span class="cov4" title="3">{
                c.conn.SetDeadline(time.Now().Add(c.commTimeout))
        }</span>
        <span class="cov7" title="10">hdr, err := readHeader(r)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="9">if hdr.payloadLen &gt; maxPayloadLen </span><span class="cov0" title="0">{
                return nil, errors.Errorf("received oversized frame (%d len)", hdr.payloadLen) // restart the connection
        }</span>

        <span class="cov7" title="9">if c.conn != nil </span><span class="cov2" title="2">{
                c.conn.SetDeadline(time.Now().Add(c.commTimeout))
        }</span>
        <span class="cov7" title="9">payload, err := readPayload(r, hdr.payloadLen)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="9">c.logger.Debug().
                Uint16("channel", hdr.channelID).
                Bool("is_command", hdr.isCommand).
                Uint32("payload_len", hdr.payloadLen).
                Str("payload", string(payload)).
                Msg("data from broker")

        return &amp;noitPacket{
                header:  hdr,
                payload: payload,
        }, nil</span>
}

// readHeader reads 6 bytes from the broker connection
func readHeader(r io.Reader) (*noitHeader, error) <span class="cov8" title="13">{
        hdrSize := 6

        data, err := readPayload(r, uint32(hdrSize))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="12">encodedChannelID := binary.BigEndian.Uint16(data)
        hdr := &amp;noitHeader{
                channelID:  encodedChannelID &amp; 0x7fff,
                isCommand:  encodedChannelID&amp;0x8000 &gt; 0,
                payloadLen: binary.BigEndian.Uint32(data[2:]),
        }

        return hdr, nil</span>
}

// readPayload consumes n bytes from the broker connection
func readPayload(r io.Reader, size uint32) ([]byte, error) <span class="cov10" title="26">{
        if size == 0 </span><span class="cov2" title="2">{
                return []byte{}, nil
        }</span>
        <span class="cov9" title="24">data, err := readBytes(r, int64(size))
        if err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>
        <span class="cov9" title="22">return data, nil</span>
}

// readBytes attempts to reads &lt;size&gt; bytes from broker connection.
func readBytes(r io.Reader, size int64) ([]byte, error) <span class="cov9" title="25">{
        buff := make([]byte, 0, size)
        lr := io.LimitReader(r, size)

        n, err := lr.Read(buff[:cap(buff)])
        if n == 0 &amp;&amp; err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // dealing with expected sizes
        <span class="cov9" title="24">if int64(n) != size </span><span class="cov1" title="1">{
                sz := 30
                if n &lt; 30 </span><span class="cov1" title="1">{
                        sz = n
                }</span>
                <span class="cov1" title="1">return nil, errors.Errorf("invalid read, expected bytes %d got %d (%#v = %s)", size, n, buff[0:sz], string(buff[0:sz]))</span>
        }

        <span class="cov9" title="23">return buff[:n], nil</span>
}

// buildFrame creates a frame to send to broker.
// recipe:
// bytes 1-6 header
//      2 bytes channel id and command flag
//      4 bytes length of data
// bytes 7-n are data, where 0 &lt; n &lt;= maxPayloadLen
func buildFrame(channelID uint16, isCommand bool, payload []byte) []byte <span class="cov8" title="15">{
        frame := make([]byte, len(payload)+6)

        var cmdFlag uint16
        if isCommand </span><span class="cov6" title="8">{
                cmdFlag = 0x8000
        }</span>

        <span class="cov8" title="15">copy(frame[6:], payload)
        binary.BigEndian.PutUint16(frame[0:], channelID&amp;0x7fff|cmdFlag)
        binary.BigEndian.PutUint32(frame[2:], uint32(len(payload)))

        return frame</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package reverse

import (
        "crypto/tls"
        "fmt"
        "math/rand"
        "net"
        "time"

        "github.com/pkg/errors"
)

// handler connects to the broker and reads commands sent by the broker
func (c *Connection) handler() error <span class="cov1" title="1">{
        defer close(c.cmdCh)
        for </span><span class="cov1" title="1">{ // allow reconnecting

                if c.shutdown() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov1" title="1">cerr := c.connect()
                if c.shutdown() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov1" title="1">if cerr != nil </span><span class="cov0" title="0">{
                        if cerr.fatal </span><span class="cov0" title="0">{
                                return cerr
                        }</span>
                        <span class="cov0" title="0">c.logger.Warn().Err(cerr).Int("attempt", c.connAttempts).Msg("connect failed")</span>
                }
                <span class="cov1" title="1">if c.conn == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">for </span><span class="cov5" title="2">{
                        if c.shutdown() </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov5" title="2">cmd, err := c.getCommandFromBroker(c.conn)
                        if c.shutdown() </span><span class="cov1" title="1">{
                                return nil
                        }</span>
                        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                                c.logger.Warn().Err(err).Msg("reading commands, resetting connection")
                                break</span>
                        }
                        <span class="cov1" title="1">if cmd != nil </span><span class="cov1" title="1">{
                                c.cmdCh &lt;- cmd
                        }</span>
                }
        }
}

// processor handles commands from broker
func (c *Connection) processor() error <span class="cov1" title="1">{
        for </span><span class="cov5" title="2">{
                select </span>{
                case &lt;-c.t.Dying():<span class="cov1" title="1">
                        return nil</span>
                case nc := &lt;-c.cmdCh:<span class="cov1" title="1">
                        if nc.command != noitCmdConnect </span><span class="cov0" title="0">{
                                c.logger.Debug().Str("cmd", nc.command).Msg("ignoring command")
                                break</span>
                        }

                        <span class="cov1" title="1">if len(nc.request) == 0 </span><span class="cov1" title="1">{
                                c.logger.Debug().
                                        Str("cmd", nc.command).
                                        Str("req", string(nc.request)).
                                        Msg("ignoring zero length request")
                                break</span>
                        }

                        <span class="cov0" title="0">if c.shutdown() </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Successfully connected, sent, and received data.
                        // In certain circumstances, a broker will allow a connection, accept
                        // the initial introduction, and then summarily disconnect (e.g. multiple
                        // agents attempting reverse connections for the same check.)
                        <span class="cov0" title="0">if c.connAttempts &gt; 0 </span><span class="cov0" title="0">{
                                c.resetConnectionAttempts()
                        }</span>

                        // NOTE: do not check whether shutting down for the next two
                        //       let the metrics go ahead and be sent through for
                        //       the channel in the request from the broker.
                        //       then exit at the start of the next iteration.
                        //
                        // send the request from the broker to the local agent
                        <span class="cov0" title="0">data, err := c.fetchMetricData(&amp;nc.request)
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Warn().Err(err).Msg("fetching metric data")
                        }</span>
                        // send the metrics received from the local agent back to the broker
                        // NOTE: send even if metrics will be empty
                        <span class="cov0" title="0">if err := c.sendMetricData(c.conn, nc.channelID, data); err != nil </span><span class="cov0" title="0">{
                                c.logger.Warn().Err(err).Msg("sending metric data")
                        }</span>
                }
        }
}

// connect to broker via w/tls and send initial introduction to start reverse
// NOTE: all reverse connections require tls
func (c *Connection) connect() *connError <span class="cov10" title="4">{
        if c.conn != nil </span><span class="cov0" title="0">{
                c.conn.Close()
        }</span>

        <span class="cov10" title="4">c.Lock()
        c.conn = nil
        c.Unlock()

        if c.connAttempts &gt; 0 </span><span class="cov0" title="0">{
                c.logger.Info().
                        Str("delay", c.delay.String()).
                        Int("attempt", c.connAttempts).
                        Msg("connect retry")

                time.Sleep(c.delay)
                c.setNextDelay()

                // Under normal circumstances the configuration for reverse is
                // non-volatile. There are, however, some situations where the
                // configuration must be rebuilt. (e.g. ip of broker changed,
                // check changed to use a different broker, broker certificate
                // changes, etc.) The majority of configuration based errors are
                // fatal, no attempt is made to resolve.
                if c.connAttempts%configRetryLimit == 0 </span><span class="cov0" title="0">{
                        c.logger.Info().Int("attempts", c.connAttempts).Msg("reconfig triggered")
                        if err := c.setCheckConfig(); err != nil </span><span class="cov0" title="0">{
                                return &amp;connError{fatal: true, err: errors.Wrap(err, "reconfiguring reverse connection")}
                        }</span>
                }
        }

        <span class="cov10" title="4">if c.shutdown() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov10" title="4">c.logger.Info().Str("host", c.reverseURL.Host).Msg("Connecting")
        c.Lock()
        c.connAttempts++
        c.Unlock()
        dialer := &amp;net.Dialer{Timeout: c.dialerTimeout}
        conn, err := tls.DialWithDialer(dialer, "tcp", c.reverseURL.Host, c.tlsConfig)
        if err != nil </span><span class="cov5" title="2">{
                if c.connAttempts &gt;= maxConnRetry </span><span class="cov0" title="0">{
                        return &amp;connError{fatal: true, err: errors.Wrapf(err, "after %d failed attempts, last error", c.connAttempts)}
                }</span>
                <span class="cov5" title="2">return &amp;connError{fatal: false, err: errors.Wrapf(err, "connecting to %s", c.reverseURL.Host)}</span>
        }

        <span class="cov5" title="2">conn.SetDeadline(time.Now().Add(c.commTimeout))
        introReq := "REVERSE " + c.reverseURL.Path
        if c.reverseURL.Fragment != "" </span><span class="cov5" title="2">{
                introReq += "#" + c.reverseURL.Fragment // reverse secret is placed here when reverse url is parsed
        }</span>
        <span class="cov5" title="2">c.logger.Debug().Msg(fmt.Sprintf("sending intro '%s'", introReq))
        if _, err := fmt.Fprintf(conn, "%s HTTP/1.1\r\n\r\n", introReq); err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;connError{fatal: false, err: errors.Wrapf(err, "unable to write intro to %s", c.reverseURL.Host)}
                }</span>
        }

        <span class="cov5" title="2">c.Lock()
        c.conn = conn
        c.Unlock()
        return nil</span>
}

// setNextDelay for failed connection attempts
func (c *Connection) setNextDelay() <span class="cov8" title="3">{
        if c.delay == c.maxDelay </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov5" title="2">c.Lock()
        defer c.Unlock()

        if c.delay &lt; c.maxDelay </span><span class="cov1" title="1">{
                drift := rand.Intn(maxDelayStep-minDelayStep) + minDelayStep
                c.delay += time.Duration(drift) * time.Second
        }</span>

        <span class="cov5" title="2">if c.delay &gt; c.maxDelay </span><span class="cov1" title="1">{
                c.delay = c.maxDelay
        }</span>
}

// resetConnectionAttempts on successful send/receive
func (c *Connection) resetConnectionAttempts() <span class="cov1" title="1">{
        if c.connAttempts &gt; 0 </span><span class="cov1" title="1">{
                c.Lock()
                c.delay = 1 * time.Second
                c.connAttempts = 0
                c.Unlock()
        }</span>
}

// Error returns string representation of a connError
func (e *connError) Error() string <span class="cov5" title="2">{
        return e.err.Error()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package reverse

import (
        crand "crypto/rand"
        "math"
        "math/big"
        "math/rand"
        "strings"
        "time"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

func init() <span class="cov1" title="1">{
        n, err := crand.Int(crand.Reader, big.NewInt(math.MaxInt64))
        if err != nil </span><span class="cov0" title="0">{
                rand.Seed(time.Now().UTC().UnixNano())
                return
        }</span>
        <span class="cov1" title="1">rand.Seed(n.Int64())</span>
}

// New creates a new connection
func New() (*Connection, error) <span class="cov10" title="34">{
        c := Connection{
                checkCID:      viper.GetString(config.KeyReverseCID),
                cmdCh:         make(chan *noitCommand),
                commTimeout:   commTimeoutSeconds * time.Second,
                connAttempts:  0,
                delay:         1 * time.Second,
                dialerTimeout: dialerTimeoutSeconds * time.Second,
                enabled:       viper.GetBool(config.KeyReverse),
                logger:        log.With().Str("pkg", "reverse").Logger(),
                maxDelay:      maxDelaySeconds * time.Second,
                metricTimeout: metricTimeoutSeconds * time.Second,
        }

        if c.enabled </span><span class="cov2" title="2">{
                c.agentAddress = strings.Replace(viper.GetString(config.KeyListen), "0.0.0.0", "localhost", -1)
                err := c.setCheckConfig()
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov9" title="33">return &amp;c, nil</span>
}

// Start reverse connection to the broker
func (c *Connection) Start() error <span class="cov2" title="2">{
        if !c.enabled </span><span class="cov1" title="1">{
                c.logger.Info().Msg("Reverse disabled, not starting")
                return nil
        }</span>

        <span class="cov1" title="1">c.logger.Info().
                Str("check_bundle", viper.GetString(config.KeyReverseCID)).
                Str("rev_host", c.reverseURL.Hostname()).
                Str("rev_port", c.reverseURL.Port()).
                Str("rev_path", c.reverseURL.Path).
                Str("agent", c.agentAddress).
                Msg("Reverse configuration")

        c.t.Go(c.handler)
        c.t.Go(c.processor)

        return c.t.Wait()</span>
}

// Stop the reverse connection
func (c *Connection) Stop() <span class="cov5" title="6">{
        if !c.enabled </span><span class="cov4" title="4">{
                return
        }</span>

        <span class="cov2" title="2">c.logger.Info().Msg("Stopping reverse connection")

        if c.t.Alive() </span><span class="cov2" title="2">{
                c.t.Kill(nil)
        }</span>

        <span class="cov2" title="2">if c.conn == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov1" title="1">c.logger.Info().Msg("Closing reverse connection")
        err := c.conn.Close()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn().Err(err).Msg("Closing reverse connection")
        }</span>
}

// shutdown checks whether tomb is dying
func (c *Connection) shutdown() bool <span class="cov9" title="23">{
        select </span>{
        case &lt;-c.t.Dying():<span class="cov2" title="2">
                return true</span>
        default:<span class="cov8" title="21">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package reverse

import (
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "net"
        "time"

        "github.com/pkg/errors"
)

// sendMetricData frames and sends data (in chunks &lt;= maxPayloadLen) to broker
func (c *Connection) sendMetricData(r io.Writer, channelID uint16, data *[]byte) error <span class="cov8" title="1">{
        empty := []byte("{}")
        if data == nil </span><span class="cov0" title="0">{
                data = &amp;empty
        }</span>
        <span class="cov8" title="1">for offset := 0; offset &lt; len(*data); </span><span class="cov8" title="1">{
                buff := make([]byte, int(math.Min(float64(len((*data)[offset:])), float64(maxPayloadLen))))
                copy(buff, (*data)[offset:])
                frame := buildFrame(channelID, false, buff)
                c.logger.Debug().
                        Str("frame_hdr", fmt.Sprintf("%#v", frame[0:6])).
                        Int("frame_size", len(frame)).
                        Int("payload_len", len(buff)).
                        Msg("metric payload frame")
                if c.conn != nil </span><span class="cov0" title="0">{
                        c.conn.SetDeadline(time.Now().Add(c.commTimeout))
                }</span>
                <span class="cov8" title="1">sentBytes, err := r.Write(frame)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "writing metric data")
                }</span>
                <span class="cov8" title="1">offset += sentBytes</span>
        }

        <span class="cov8" title="1">c.logger.Debug().
                Int("bytes", len(*data)).
                Msg("metric data sent")

        return nil</span>
}

// fetchMetricData sends the command arguments to the local agent
func (c *Connection) fetchMetricData(request *[]byte) (*[]byte, error) <span class="cov8" title="1">{
        conn, err := net.DialTimeout("tcp", c.agentAddress, c.dialerTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "connecting to agent for metrics")
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        // set total transaction timeout (agent is local...).
        // complete, roundtrip transaction to get metrics
        // should take *less* than polling interval
        // with graph/dashboard _play_, metrics will go
        // back to broker as fast as possible, gated by
        // plugin execution speed
        conn.SetDeadline(time.Now().Add(c.metricTimeout))

        numBytes, err := conn.Write(*request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "writing metric request")
        }</span>
        <span class="cov8" title="1">if numBytes != len(*request) </span><span class="cov0" title="0">{
                c.logger.Warn().
                        Int("written_bytes", numBytes).
                        Int("request_len", len(*request)).
                        Msg("Mismatch")
        }</span>

        <span class="cov8" title="1">data, err := ioutil.ReadAll(conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "reading metric data")
        }</span>

        <span class="cov8" title="1">return &amp;data, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package server

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/circonus-labs/circonus-agent/internal/server/receiver"
        cgm "github.com/circonus-labs/circonus-gometrics"
        "github.com/spf13/viper"
)

// run handles requests to execute plugins and return metrics emitted
// handles /, /run, or /run/plugin_name
func (s *Server) run(w http.ResponseWriter, r *http.Request) <span class="cov9" title="10">{
        plugin := ""

        if strings.HasPrefix(r.URL.Path, "/run/") </span><span class="cov7" title="6">{ // run specific plugin
                plugin = strings.Replace(r.URL.Path, "/run/", "", -1)
                if plugin != "" </span><span class="cov6" title="5">{
                        if !s.plugins.IsInternal(plugin) &amp;&amp; !s.plugins.IsValid(plugin) </span><span class="cov3" title="2">{
                                s.logger.Warn().
                                        Str("plugin", plugin).
                                        Msg("Unknown plugin requested")
                                http.NotFound(w, r)
                                return
                        }</span>
                }
        }

        <span class="cov8" title="8">lastMeticsmu.Lock()
        defer lastMeticsmu.Unlock()

        metrics := map[string]interface{}{}

        if plugin == "" || !s.plugins.IsInternal(plugin) </span><span class="cov7" title="6">{
                // NOTE: errors are ignored from plugins.Run
                //       1. errors are already logged by Run
                //       2. do not expose execution state to callers
                s.plugins.Run(plugin)
                pluginMetrics := s.plugins.Flush(plugin)
                metrics = *pluginMetrics
        }</span>

        <span class="cov8" title="8">if plugin == "" || plugin == "write" </span><span class="cov7" title="6">{
                receiverMetrics := receiver.Flush()
                for metricName, metric := range *receiverMetrics </span><span class="cov1" title="1">{
                        metrics[metricName] = metric
                }</span>
        }

        <span class="cov8" title="8">if plugin == "" || plugin == "statsd" </span><span class="cov7" title="6">{
                if s.statsdSvr != nil </span><span class="cov0" title="0">{
                        statsdMetrics := s.statsdSvr.Flush()
                        if statsdMetrics != nil </span><span class="cov0" title="0">{
                                metrics[viper.GetString(config.KeyStatsdHostCategory)] = statsdMetrics
                        }</span>
                }
        }

        <span class="cov8" title="8">lastMetrics.metrics = metrics
        lastMetrics.ts = time.Now()

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(metrics); err != nil </span><span class="cov0" title="0">{
                s.logger.Error().
                        Err(err).
                        Msg("Writing metrics to response")
        }</span>
}

// inventory returns the current, active plugin inventory
func (s *Server) inventory(w http.ResponseWriter, r *http.Request) <span class="cov4" title="3">{
        inventory := s.plugins.Inventory()
        if inventory == nil </span><span class="cov0" title="0">{
                inventory = []byte(`{"error": "empty inventory"}`)
                s.logger.Error().Msg("inventory is nil/empty...")
        }</span>

        <span class="cov4" title="3">w.Header().Set("Content-Type", "application/json")
        w.Write(inventory)</span>
}

// write handles PUT/POST requests with a JSON playload containing "freeform"
// metrics. No validation is applied to the "format" of the metrics beyond k/v.
// Where 'key' is the metric name and 'value' is the metric value as either a
// simple value (e.g. {"name": 1, "foo": "bar", ...}) or a structured value
// representation (e.g. {"foo": {_type: "i", _value: 1}, ...}).
func (s *Server) write(w http.ResponseWriter, r *http.Request) <span class="cov7" title="6">{
        id := strings.Replace(r.URL.Path, "/write/", "", -1)

        s.logger.Debug().Str("path", r.URL.Path).Str("id", id).Msg("write request")
        // a write request *MUST* include a metric group id to act as a namespace.
        // in other words, a "plugin name", all metrics for that write will appear
        // _under_ the metric group id (aka plugin name)
        if id == "" </span><span class="cov1" title="1">{
                http.NotFound(w, r)
                return
        }</span>

        <span class="cov6" title="5">if err := receiver.Parse(id, r.Body); err != nil </span><span class="cov4" title="3">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="2">w.WriteHeader(http.StatusNoContent)</span>
}

// promOutput returns the last metrics in prom format
func (s *Server) promOutput(w http.ResponseWriter, r *http.Request) <span class="cov5" title="4">{
        if lastMetrics.metrics == nil || len(lastMetrics.metrics) == 0 </span><span class="cov4" title="3">{
                w.WriteHeader(http.StatusNoContent)
                return
        }</span>

        <span class="cov1" title="1">ms := lastMetrics.ts.UnixNano() / int64(time.Millisecond)

        w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)
        for id, data := range lastMetrics.metrics </span><span class="cov1" title="1">{
                s.metricsToPromFormat(w, id, ms, data)
        }</span>
}

func (s *Server) metricsToPromFormat(w io.Writer, prefix string, ts int64, val interface{}) <span class="cov10" title="13">{
        l := s.logger.With().Str("op", "prom export").Logger()
        switch t := val.(type) </span>{
        case cgm.Metric:<span class="cov8" title="8">
                metric := val.(cgm.Metric)
                sv := fmt.Sprintf("%v", metric.Value)
                switch metric.Type </span>{
                case "i":<span class="cov4" title="3">
                        fallthrough</span>
                case "I":<span class="cov4" title="3">
                        fallthrough</span>
                case "l":<span class="cov4" title="3">
                        fallthrough</span>
                case "L":<span class="cov4" title="3">
                        v, err := strconv.ParseInt(sv, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                l.Error().Err(err).Msg("conv int64")
                                return
                        }</span>
                        <span class="cov3" title="2">if _, err := w.Write([]byte(fmt.Sprintf("%s %d %d\n", prefix, v, ts))); err != nil </span><span class="cov0" title="0">{
                                l.Error().Err(err).Msg("writing prom output")
                        }</span>
                case "n":<span class="cov4" title="3">
                        if strings.Contains(sv, "[H[") </span><span class="cov1" title="1">{
                                l.Warn().
                                        Str("type", "histogram != [prom]histogram(percentile)").
                                        Str("metric", fmt.Sprintf("%s = %s", prefix, sv)).
                                        Msg("unsupported metric type")
                        }</span><span class="cov3" title="2"> else {
                                v, err := strconv.ParseFloat(sv, 64)
                                if err != nil </span><span class="cov1" title="1">{
                                        l.Error().Err(err).Msg("conv float64")
                                        return
                                }</span>
                                <span class="cov1" title="1">if _, err := w.Write([]byte(fmt.Sprintf("%s %f %d\n", prefix, v, ts))); err != nil </span><span class="cov0" title="0">{
                                        l.Error().Err(err).Msg("writing prom output")
                                }</span>
                        }
                case "s":<span class="cov1" title="1">
                        l.Warn().
                                Str("type", "text [prom]???").
                                Str("metric", fmt.Sprintf("%s = %s", prefix, sv)).
                                Msg("unsuported metric type")</span>
                default:<span class="cov1" title="1">
                        l.Warn().
                                Str("type", metric.Type).
                                Str("name", prefix).
                                Interface("metric", metric).
                                Msg("invalid metric type")</span>
                }
        case cgm.Metrics:<span class="cov3" title="2">
                metrics := val.(cgm.Metrics)
                for pfx, metric := range metrics </span><span class="cov3" title="2">{
                        name := prefix
                        if pfx != "" </span><span class="cov3" title="2">{
                                name = strings.Join([]string{name, pfx}, config.MetricNameSeparator)
                        }</span>
                        <span class="cov3" title="2">s.metricsToPromFormat(w, name, ts, metric)</span>
                }
        case *cgm.Metrics:<span class="cov3" title="2">
                metrics := val.(*cgm.Metrics)
                s.metricsToPromFormat(w, prefix, ts, *metrics)</span>
        default:<span class="cov1" title="1">
                l.Warn().
                        Str("metric", fmt.Sprintf("#TYPE(%T) %v = %#v", t, prefix, val)).
                        Msg("unhandled export type")</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package server

import (
        "net/http"

        "github.com/circonus-labs/circonus-agent/internal/config"
        "github.com/circonus-labs/circonus-agent/internal/plugins"
        "github.com/circonus-labs/circonus-agent/internal/statsd"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
        "xi2.org/x/httpgzip"
)

// New creates a new instance of the listening servers
func New(p *plugins.Plugins, ss *statsd.Server) (*Server, error) <span class="cov10" title="23">{
        s := Server{
                logger:    log.With().Str("pkg", "server").Logger(),
                plugins:   p,
                statsdSvr: ss,
        }

        gzipHandler := httpgzip.NewHandler(http.HandlerFunc(s.router), []string{"application/json"})

        if addr := viper.GetString(config.KeyListen); addr != "" </span><span class="cov4" title="4">{
                s.svrHTTP = &amp;http.Server{Addr: addr, Handler: gzipHandler}
                s.svrHTTP.SetKeepAlivesEnabled(false)
        }</span>

        <span class="cov10" title="23">if addr := viper.GetString(config.KeySSLListen); addr != "" </span><span class="cov5" title="5">{
                s.svrHTTPS = &amp;http.Server{Addr: addr, Handler: gzipHandler}
                s.svrHTTPS.SetKeepAlivesEnabled(false)
        }</span>

        <span class="cov10" title="23">return &amp;s, nil</span>
}

// Start main listening server(s)
func (s *Server) Start() error <span class="cov5" title="5">{
        if s.svrHTTP == nil &amp;&amp; s.svrHTTPS == nil </span><span class="cov0" title="0">{
                return errors.New("No servers defined")
        }</span>

        <span class="cov5" title="5">s.t.Go(s.startHTTP)
        s.t.Go(s.startHTTPS)

        return s.t.Wait()</span>
}

// Stop the servers
func (s *Server) Stop() <span class="cov5" title="5">{
        if s.svrHTTP != nil </span><span class="cov1" title="1">{
                s.logger.Info().Msg("Stopping HTTP server")
                err := s.svrHTTP.Close()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Msg("Closing HTTP server")
                }</span>
        }

        <span class="cov5" title="5">if s.svrHTTPS != nil </span><span class="cov4" title="4">{
                s.logger.Info().Msg("Stopping HTTPS server")
                err := s.svrHTTPS.Close()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn().Err(err).Msg("Closing HTTPS server")
                }</span>
        }

        <span class="cov5" title="5">if s.t.Alive() </span><span class="cov1" title="1">{
                s.t.Kill(nil)
        }</span>
}

func (s *Server) startHTTP() error <span class="cov5" title="5">{
        if s.svrHTTP == nil </span><span class="cov4" title="4">{
                s.logger.Debug().Msg("No listen configured, skipping server")
                return nil
        }</span>
        <span class="cov1" title="1">s.logger.Info().Str("listen", s.svrHTTP.Addr).Msg("Starting")
        if err := s.svrHTTP.ListenAndServe(); err != nil </span><span class="cov1" title="1">{
                if err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "HTTP server")
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (s *Server) startHTTPS() error <span class="cov5" title="5">{
        if s.svrHTTPS == nil </span><span class="cov1" title="1">{
                s.logger.Debug().Msg("No SSL listen configured, skipping server")
                return nil
        }</span>
        <span class="cov4" title="4">certFile := viper.GetString(config.KeySSLCertFile)
        keyFile := viper.GetString(config.KeySSLKeyFile)
        s.logger.Info().Str("listen", s.svrHTTPS.Addr).Msg("SSL starting")
        if err := s.svrHTTPS.ListenAndServeTLS(certFile, keyFile); err != nil </span><span class="cov4" title="4">{
                if err != http.ErrServerClosed </span><span class="cov4" title="4">{
                        return errors.Wrap(err, "HTTPS server")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package receiver

import (
        "encoding/json"
        "fmt"
        "io"
        stdlog "log"
        "strconv"
        "strings"

        "github.com/circonus-labs/circonus-agent/internal/config"
        cgm "github.com/circonus-labs/circonus-gometrics"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

func initCGM() error <span class="cov10" title="17">{
        metricsmu.Lock()
        defer metricsmu.Unlock()

        if metrics != nil </span><span class="cov9" title="16">{
                return nil
        }</span>

        <span class="cov1" title="1">cmc := &amp;cgm.Config{
                Debug: viper.GetBool(config.KeyDebugCGM),
                Log:   stdlog.New(log.With().Str("pkg", "receiver").Logger(), "", 0),
        }
        // put cgm into manual mode (no interval, no api key, invalid submission url)
        cmc.Interval = "0"                            // disable automatic flush
        cmc.CheckManager.Check.SubmissionURL = "none" // disable check management (create/update)

        hm, err := cgm.NewCirconusMetrics(cmc)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "receiver cgm")
        }</span>

        <span class="cov1" title="1">metrics = hm
        return nil</span>
}

// Flush returns current metrics
func Flush() *cgm.Metrics <span class="cov3" title="2">{
        initCGM()
        metricsmu.Lock()
        defer metricsmu.Unlock()

        return metrics.FlushMetrics()
}</span>

// Parse handles incoming PUT/POST requests
func Parse(id string, data io.ReadCloser) error <span class="cov9" title="13">{
        initCGM()
        metricsmu.Lock()
        defer metricsmu.Unlock()

        var tmp cgm.Metrics
        if err := json.NewDecoder(data).Decode(&amp;tmp); err != nil </span><span class="cov5" title="4">{
                if serr, ok := err.(*json.SyntaxError); ok </span><span class="cov1" title="1">{
                        return errors.Wrapf(serr, "id:%s - offset %d", id, serr.Offset)
                }</span>
                <span class="cov4" title="3">return errors.Wrapf(err, "parsing json for %s", id)</span>
        }

        <span class="cov7" title="9">for name, metric := range tmp </span><span class="cov7" title="8">{
                metricName := strings.Join([]string{id, name}, config.MetricNameSeparator)
                switch metric.Type </span>{
                case "i":<span class="cov1" title="1">
                        if v := parseInt32(metricName, metric); v != nil </span><span class="cov1" title="1">{
                                metrics.AddGauge(metricName, *v)
                        }</span>
                case "I":<span class="cov1" title="1">
                        if v := parseUint32(metricName, metric); v != nil </span><span class="cov1" title="1">{
                                metrics.AddGauge(metricName, *v)
                        }</span>
                case "l":<span class="cov1" title="1">
                        if v := parseInt64(metricName, metric); v != nil </span><span class="cov1" title="1">{
                                metrics.AddGauge(metricName, *v)
                        }</span>
                case "L":<span class="cov1" title="1">
                        if v := parseUint64(metricName, metric); v != nil </span><span class="cov1" title="1">{
                                metrics.AddGauge(metricName, *v)
                        }</span>
                case "n":<span class="cov3" title="2">
                        v, isHist := parseFloat(metricName, metric)
                        if v != nil </span><span class="cov1" title="1">{
                                metrics.AddGauge(metricName, *v)
                        }</span><span class="cov1" title="1"> else if isHist </span><span class="cov1" title="1">{
                                samples := parseHistogram(metricName, metric)
                                if samples != nil &amp;&amp; len(*samples) &gt; 0 </span><span class="cov1" title="1">{
                                        for _, sample := range *samples </span><span class="cov1" title="1">{
                                                metrics.RecordValue(metricName, sample)
                                        }</span>
                                }
                        }
                case "s":<span class="cov1" title="1">
                        metrics.SetText(metricName, fmt.Sprintf("%v", metric.Value))</span>
                default:<span class="cov1" title="1">
                        log.Warn().Str("metric", metricName).Str("type", metric.Type).Str("pkg", "receiver").Msg("unsupported metric type")</span>
                }
        }

        <span class="cov7" title="9">return nil</span>
}

func parseInt32(metricName string, metric cgm.Metric) *int32 <span class="cov6" title="5">{
        switch t := metric.Value.(type) </span>{
        case float64:<span class="cov3" title="2">
                v := int32(metric.Value.(float64))
                return &amp;v</span>
        case string:<span class="cov3" title="2">
                v, err := strconv.ParseInt(metric.Value.(string), 10, 32)
                if err == nil </span><span class="cov1" title="1">{
                        v2 := int32(v)
                        return &amp;v2
                }</span>
                <span class="cov1" title="1">log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Err(err).
                        Msg("parsing")</span>
        default:<span class="cov1" title="1">
                log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Str("type", fmt.Sprintf("%T", t)).
                        Msg("invalid value type for metric type")</span>
        }
        <span class="cov3" title="2">return nil</span>
}

func parseUint32(metricName string, metric cgm.Metric) *uint32 <span class="cov6" title="5">{
        switch t := metric.Value.(type) </span>{
        case float64:<span class="cov3" title="2">
                v := uint32(metric.Value.(float64))
                return &amp;v</span>
        case string:<span class="cov3" title="2">
                v, err := strconv.ParseUint(metric.Value.(string), 10, 32)
                if err == nil </span><span class="cov1" title="1">{
                        v2 := uint32(v)
                        return &amp;v2
                }</span>
                <span class="cov1" title="1">log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Err(err).
                        Msg("parsing")</span>
        default:<span class="cov1" title="1">
                log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Str("type", fmt.Sprintf("%T", t)).
                        Msg("invalid value type for metric type")</span>
        }
        <span class="cov3" title="2">return nil</span>
}

func parseInt64(metricName string, metric cgm.Metric) *int64 <span class="cov6" title="5">{
        switch t := metric.Value.(type) </span>{
        case float64:<span class="cov3" title="2">
                v := int64(metric.Value.(float64))
                return &amp;v</span>
        case string:<span class="cov3" title="2">
                v, err := strconv.ParseInt(metric.Value.(string), 10, 64)
                if err == nil </span><span class="cov1" title="1">{
                        v2 := int64(v)
                        return &amp;v2
                }</span>
                <span class="cov1" title="1">log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Err(err).
                        Msg("parsing")</span>
        default:<span class="cov1" title="1">
                log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Str("type", fmt.Sprintf("%T", t)).
                        Msg("invalid value type for metric type")</span>
        }
        <span class="cov3" title="2">return nil</span>
}

func parseUint64(metricName string, metric cgm.Metric) *uint64 <span class="cov6" title="5">{
        switch t := metric.Value.(type) </span>{
        case float64:<span class="cov3" title="2">
                v := uint64(metric.Value.(float64))
                return &amp;v</span>
        case string:<span class="cov3" title="2">
                v, err := strconv.ParseUint(metric.Value.(string), 10, 64)
                if err == nil </span><span class="cov1" title="1">{
                        v2 := uint64(v)
                        return &amp;v2
                }</span>
                <span class="cov1" title="1">log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Err(err).
                        Msg("parsing")</span>
        default:<span class="cov1" title="1">
                log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Str("type", fmt.Sprintf("%T", t)).
                        Msg("invalid value type for metric type")</span>
        }
        <span class="cov3" title="2">return nil</span>
}

func parseFloat(metricName string, metric cgm.Metric) (*float64, bool) <span class="cov7" title="8">{
        switch t := metric.Value.(type) </span>{
        case float64:<span class="cov4" title="3">
                v := metric.Value.(float64)
                return &amp;v, false</span>
        case []interface{}:<span class="cov1" title="1"> // treat as histogram
                return nil, true</span>
        case string:<span class="cov4" title="3">
                v, err := strconv.ParseFloat(metric.Value.(string), 64)
                if err == nil </span><span class="cov3" title="2">{
                        v2 := float64(v)
                        return &amp;v2, false
                }</span>
                <span class="cov1" title="1">log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Err(err).
                        Msg("parsing")</span>
        default:<span class="cov1" title="1">
                log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Str("type", fmt.Sprintf("%T", t)).
                        Msg("invalid value type for metric type")</span>
        }
        <span class="cov3" title="2">return nil, false</span>
}

func parseHistogram(metricName string, metric cgm.Metric) *[]float64 <span class="cov7" title="8">{
        switch t := metric.Value.(type) </span>{
        case []interface{}:<span class="cov7" title="7">
                ret := make([]float64, 0, len(metric.Value.([]interface{})))
                for idx, v := range metric.Value.([]interface{}) </span><span class="cov7" title="7">{
                        switch t2 := v.(type) </span>{
                        case float64:<span class="cov4" title="3">
                                ret = append(ret, v.(float64))</span>
                        case string:<span class="cov4" title="3">
                                v2, err := strconv.ParseFloat(v.(string), 64)
                                if err != nil </span><span class="cov1" title="1">{
                                        log.Error().
                                                Str("pkg", "receiver").
                                                Str("metric", metricName).
                                                Interface("value", v).
                                                Int("position", idx).
                                                Err(err).
                                                Msg("parsing histogram sample")
                                        continue</span>
                                }
                                <span class="cov3" title="2">ret = append(ret, float64(v2))</span>
                        default:<span class="cov1" title="1">
                                log.Error().
                                        Str("pkg", "receiver").
                                        Str("metric", metricName).
                                        Interface("value", v).
                                        Int("position", idx).
                                        Str("type", fmt.Sprintf("%T", t2)).
                                        Msg("invalid value type for histogram sample")</span>
                        }
                }
                <span class="cov7" title="7">if len(ret) == 0 </span><span class="cov3" title="2">{
                        return nil
                }</span>
                <span class="cov6" title="5">return &amp;ret</span>
        default:<span class="cov1" title="1">
                log.Error().
                        Str("pkg", "receiver").
                        Str("metric", metricName).
                        Interface("value", metric).
                        Str("type", fmt.Sprintf("%T", t)).
                        Msg("invalid value type for histogram")</span>
        }
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package server

import (
        "expvar"
        "net/http"

        "github.com/maier/go-appstats"
)

func (s *Server) router(w http.ResponseWriter, r *http.Request) <span class="cov10" title="25">{
        appstats.IncrementInt("requests_total")

        s.logger.Info().
                Str("method", r.Method).
                Str("url", r.URL.String()).
                Msg("Request")

        switch r.Method </span>{
        case "GET":<span class="cov7" title="12">
                if pluginPathRx.MatchString(r.URL.Path) </span><span class="cov4" title="4">{ // run plugin(s)
                        s.run(w, r)
                }</span><span class="cov6" title="8"> else if inventoryPathRx.MatchString(r.URL.Path) </span><span class="cov2" title="2">{ // plugin inventory
                        s.inventory(w, r)
                }</span><span class="cov6" title="6"> else if statsPathRx.MatchString(r.URL.Path) </span><span class="cov2" title="2">{ // app stats
                        expvar.Handler().ServeHTTP(w, r)
                }</span><span class="cov4" title="4"> else if promPathRx.MatchString(r.URL.Path) </span><span class="cov2" title="2">{ // output prom format...
                        s.promOutput(w, r)
                }</span><span class="cov2" title="2"> else {
                        appstats.IncrementInt("requests_bad")
                        s.logger.Warn().
                                Str("method", r.Method).
                                Str("url", r.URL.String()).
                                Msg("Not found")
                        http.NotFound(w, r)
                }</span>
        case "POST":<span class="cov1" title="1">
                fallthrough</span>
        case "PUT":<span class="cov6" title="8">
                if writePathRx.MatchString(r.URL.Path) </span><span class="cov5" title="5">{
                        s.write(w, r)
                }</span><span class="cov4" title="3"> else {
                        appstats.IncrementInt("requests_bad")
                        s.logger.Warn().
                                Str("method", r.Method).
                                Str("url", r.URL.String()).
                                Msg("Not found")
                        http.NotFound(w, r)
                }</span>
        default:<span class="cov5" title="5">
                appstats.IncrementInt("requests_bad")
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package statsd

import (
        "crypto/x509"
        "io/ioutil"
        stdlog "log"
        "net"
        "regexp"

        "github.com/circonus-labs/circonus-agent/internal/config"
        cgm "github.com/circonus-labs/circonus-gometrics"
        "github.com/maier/go-appstats"
        "github.com/pkg/errors"
        "github.com/rs/zerolog/log"
        "github.com/spf13/viper"
)

// New returns a statsd server definition
func New() (*Server, error) <span class="cov10" title="18">{
        s := Server{
                disabled:       viper.GetBool(config.KeyStatsdDisabled),
                logger:         log.With().Str("pkg", "statsd").Logger(),
                hostPrefix:     viper.GetString(config.KeyStatsdHostPrefix),
                hostCategory:   viper.GetString(config.KeyStatsdHostCategory),
                groupCID:       viper.GetString(config.KeyStatsdGroupCID),
                groupPrefix:    viper.GetString(config.KeyStatsdGroupPrefix),
                groupCounterOp: viper.GetString(config.KeyStatsdGroupCounters),
                groupGaugeOp:   viper.GetString(config.KeyStatsdGroupGauges),
                groupSetOp:     viper.GetString(config.KeyStatsdGroupSets),
                debugCGM:       viper.GetBool(config.KeyDebugCGM),
                apiKey:         viper.GetString(config.KeyAPITokenKey),
                apiApp:         viper.GetString(config.KeyAPITokenApp),
                apiURL:         viper.GetString(config.KeyAPIURL),
                apiCAFile:      viper.GetString(config.KeyAPICAFile),
                packetCh:       make(chan []byte, packetQueueSize),
        }

        port := viper.GetString(config.KeyStatsdPort)
        address := net.JoinHostPort("localhost", port)
        addr, err := net.ResolveUDPAddr("udp", address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "resolving address '%s'", address)
        }</span>

        <span class="cov10" title="18">s.address = addr
        s.metricRegex = regexp.MustCompile(`^(?P&lt;name&gt;[^:\s]+):(?P&lt;value&gt;[^|\s]+)\|(?P&lt;type&gt;[a-z]+)(?:@(?P&lt;sample&gt;[0-9.]+))?$`)
        s.metricRegexGroupNames = s.metricRegex.SubexpNames()

        if !s.disabled </span><span class="cov9" title="14">{
                if ierr := s.initHostMetrics(); ierr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(ierr, "Initializing host metrics for StatsD")
                }</span>

                <span class="cov9" title="14">if ierr := s.initGroupMetrics(); ierr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(ierr, "Initializing group metrics for StatsD")
                }</span>
        }

        <span class="cov10" title="18">l, err := net.ListenUDP("udp", s.address)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="18">s.listener = l

        return &amp;s, nil</span>
}

// Start the StatsD listener
func (s *Server) Start() error <span class="cov5" title="4">{
        if s.disabled </span><span class="cov1" title="1">{
                s.logger.Info().Msg("disabled, not starting listener")
                return nil
        }</span>

        <span class="cov4" title="3">s.t.Go(s.reader)
        s.t.Go(s.processor)

        return s.t.Wait()</span>
}

// Stop the server
func (s *Server) Stop() error <span class="cov4" title="3">{
        if s.disabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">s.logger.Info().Msg("Stopping StatsD Server")

        if s.t.Alive() </span><span class="cov3" title="2">{
                s.t.Kill(nil)
        }</span>

        <span class="cov3" title="2">if s.groupMetrics != nil </span><span class="cov0" title="0">{
                s.logger.Info().Msg("Flushing group metrics")
                s.groupMetricsmu.Lock()
                s.groupMetrics.Flush()
                s.groupMetricsmu.Unlock()
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// Flush *host* metrics only
// NOTE: group metrics flush independently via circonus-gometrics to a different check
func (s *Server) Flush() *cgm.Metrics <span class="cov4" title="3">{
        if s.disabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="2">if s.hostMetrics == nil </span><span class="cov1" title="1">{
                return &amp;cgm.Metrics{}
        }</span>

        <span class="cov1" title="1">s.hostMetricsmu.Lock()
        defer s.hostMetricsmu.Unlock()
        return s.hostMetrics.FlushMetrics()</span>
}

// initHostMetrics initializes the host metrics circonus-gometrics instance
func (s *Server) initHostMetrics() error <span class="cov9" title="15">{
        s.hostMetricsmu.Lock()
        defer s.hostMetricsmu.Unlock()

        cmc := &amp;cgm.Config{
                Debug: s.debugCGM,
                Log:   stdlog.New(s.logger.With().Str("pkg", "statsd-host-check").Logger(), "", 0),
        }
        // put cgm into manual mode (no interval, no api key, invalid submission url)
        cmc.Interval = "0"                            // disable automatic flush
        cmc.CheckManager.Check.SubmissionURL = "none" // disable check management (create/update)

        hm, err := cgm.NewCirconusMetrics(cmc)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "statsd host check")
        }</span>

        <span class="cov9" title="15">s.hostMetrics = hm

        s.logger.Info().Msg("host check initialized")
        return nil</span>
}

// initGroupMetrics initializes the group metric circonus-gometrics instance
// NOTE: Group metrics are sent directly to circonus, to an existing HTTPTRAP
//       check created manually or by cosi - the group check is intended to be
//       used by multiple systems.
func (s *Server) initGroupMetrics() error <span class="cov9" title="14">{
        if s.groupCID == "" </span><span class="cov9" title="14">{
                s.logger.Info().Msg("group check disabled")
                return nil
        }</span>

        <span class="cov0" title="0">s.groupMetricsmu.Lock()
        defer s.groupMetricsmu.Unlock()

        cmc := &amp;cgm.Config{
                Debug: s.debugCGM,
                Log:   stdlog.New(s.logger.With().Str("pkg", "statsd-group-check").Logger(), "", 0),
        }
        cmc.CheckManager.API.TokenKey = s.apiKey
        cmc.CheckManager.API.TokenApp = s.apiApp
        cmc.CheckManager.API.URL = s.apiURL
        cmc.CheckManager.Check.ID = s.groupCID

        if s.apiCAFile != "" </span><span class="cov0" title="0">{
                cert, err := ioutil.ReadFile(s.apiCAFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cp := x509.NewCertPool()
                if !cp.AppendCertsFromPEM(cert) </span><span class="cov0" title="0">{
                        return errors.Errorf("using api CA cert %#v", cert)
                }</span>

                <span class="cov0" title="0">cmc.CheckManager.API.CACert = cp</span>
        }

        <span class="cov0" title="0">gm, err := cgm.NewCirconusMetrics(cmc)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "statsd group check")
        }</span>

        <span class="cov0" title="0">s.groupMetrics = gm

        s.logger.Info().Msg("group check initialized")
        return nil</span>
}

// reader reads packets from the statsd listener, adds packets recevied to the queue
func (s *Server) reader() error <span class="cov4" title="3">{
        for </span><span class="cov4" title="3">{
                buff := make([]byte, maxPacketSize)
                n, err := s.listener.Read(buff)
                if s.shutdown() </span><span class="cov3" title="2">{
                        return nil
                }</span>
                <span class="cov1" title="1">if err != nil </span><span class="cov1" title="1">{
                        s.logger.Error().Err(err).Msg("reader")
                        return errors.Wrap(err, "reader")
                }</span>
                <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                        appstats.IncrementInt("statsd_packets_total")
                        pkt := make([]byte, n)
                        copy(pkt, buff[:n])
                        s.packetCh &lt;- pkt
                }</span>
        }
}

// processor reads the packet queue and processes each packet
func (s *Server) processor() error <span class="cov4" title="3">{
        defer s.listener.Close()
        for </span><span class="cov4" title="3">{
                select </span>{
                case &lt;-s.t.Dying():<span class="cov4" title="3">
                        return nil</span>
                case pkt := &lt;-s.packetCh:<span class="cov0" title="0">
                        err := s.processPacket(pkt)
                        if err != nil </span><span class="cov0" title="0">{
                                appstats.IncrementInt("statsd_packets_bad")
                                s.logger.Error().Err(err).Msg("processor")
                                return errors.Wrap(err, "processor")
                        }</span>
                }
        }
}

// shutdown checks whether tomb is dying
func (s *Server) shutdown() bool <span class="cov4" title="3">{
        select </span>{
        case &lt;-s.t.Dying():<span class="cov3" title="2">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package statsd

import (
        "bytes"
        "strconv"
        "strings"

        "github.com/circonus-labs/circonus-agent/internal/config"
        cgm "github.com/circonus-labs/circonus-gometrics"
        "github.com/maier/go-appstats"
        "github.com/pkg/errors"
)

// processPacket parses a packet for metrics
func (s *Server) processPacket(pkt []byte) error <span class="cov2" title="3">{
        if len(pkt) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="2">s.logger.Debug().Str("packet", string(pkt)).Msg("received")
        metrics := bytes.Split(pkt, []byte("\n"))
        for _, metric := range metrics </span><span class="cov2" title="3">{
                if err := s.parseMetric(string(metric)); err != nil </span><span class="cov1" title="1">{
                        appstats.IncrementInt("statsd_metrics_bad")
                        s.logger.Warn().Err(err).Str("metric", string(metric)).Msg("parsing")
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// getMetricDestination determines "where" a metric should be sent (host or group)
// and cleans up the metric name if it matches a host|group prefix
func (s *Server) getMetricDestination(metricName string) (string, string) <span class="cov7" title="41">{
        if s.hostPrefix == "" &amp;&amp; s.groupPrefix == "" </span><span class="cov7" title="32">{ // no host/group prefixes - send all metrics to host
                return destHost, metricName
        }</span>

        <span class="cov4" title="9">if s.hostPrefix != "" &amp;&amp; s.groupPrefix != "" </span><span class="cov2" title="3">{ // explicit host and group, otherwise ignore
                if strings.HasPrefix(metricName, s.hostPrefix) </span><span class="cov1" title="1">{
                        return destHost, strings.Replace(metricName, s.hostPrefix, "", 1)
                }</span>
                <span class="cov2" title="2">if strings.HasPrefix(metricName, s.groupPrefix) </span><span class="cov1" title="1">{
                        return destGroup, strings.Replace(metricName, s.groupPrefix, "", 1)
                }</span>
                <span class="cov1" title="1">s.logger.Debug().Str("metric_name", metricName).Msg("does not match host|group prefix, ignoring")
                return destIgnore, metricName</span>
        }

        <span class="cov4" title="6">if s.groupPrefix != "" &amp;&amp; s.hostPrefix == "" </span><span class="cov2" title="3">{ // default to host
                if strings.HasPrefix(metricName, s.groupPrefix) </span><span class="cov1" title="1">{
                        return destGroup, strings.Replace(metricName, s.groupPrefix, "", 1)
                }</span>
                <span class="cov2" title="2">return destHost, metricName</span>
        }

        <span class="cov2" title="3">if s.groupPrefix == "" &amp;&amp; s.hostPrefix != "" </span><span class="cov2" title="3">{ // default to group
                if strings.HasPrefix(metricName, s.hostPrefix) </span><span class="cov1" title="1">{
                        return destHost, strings.Replace(metricName, s.hostPrefix, "", 1)
                }</span>
                <span class="cov2" title="2">return destGroup, metricName</span>
        }

        <span class="cov0" title="0">s.logger.Debug().Str("metric_name", metricName).Msg("does not match host|group criteria, ignoring")
        return destIgnore, metricName</span>
}

func (s *Server) parseMetric(metric string) error <span class="cov7" title="37">{
        // ignore 'blank' lines/empty strings
        if len(metric) == 0 </span><span class="cov2" title="3">{
                return nil
        }</span>

        <span class="cov7" title="34">metricName := ""
        metricType := ""
        metricValue := ""
        metricRate := ""
        sampleRate := 0.0

        if !s.metricRegex.MatchString(metric) </span><span class="cov3" title="5">{
                return errors.Errorf("invalid metric format '%s', ignoring", metric)
        }</span>

        <span class="cov7" title="29">for _, match := range s.metricRegex.FindAllStringSubmatch(metric, -1) </span><span class="cov7" title="29">{
                for gIdx, matchVal := range match </span><span class="cov10" title="145">{
                        switch s.metricRegexGroupNames[gIdx] </span>{
                        case "name":<span class="cov7" title="29">
                                metricName = matchVal</span>
                        case "type":<span class="cov7" title="29">
                                metricType = matchVal</span>
                        case "value":<span class="cov7" title="29">
                                metricValue = matchVal</span>
                        case "sample":<span class="cov7" title="29">
                                metricRate = matchVal</span>
                        default:</span><span class="cov7" title="29">
                                // ignore any other groups
                        }
                }
        }

        <span class="cov7" title="29">if metricName == "" || metricValue == "" </span><span class="cov0" title="0">{
                return errors.Errorf("empty metric name (%s) or metric value (%s) - metricRegex failed, check", metricName, metricValue)
        }</span>

        <span class="cov7" title="29">if metricRate != "" </span><span class="cov3" title="4">{
                r, err := strconv.ParseFloat(metricRate, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Errorf("invalid metric sampling rate (%s), ignoring", err)
                }</span>
                <span class="cov3" title="4">sampleRate = r</span>
        }

        <span class="cov7" title="29">var (
                dest       *cgm.CirconusMetrics
                metricDest string
        )
        metricDest, metricName = s.getMetricDestination(metricName)

        if metricDest == destGroup </span><span class="cov0" title="0">{
                dest = s.groupMetrics
        }</span><span class="cov7" title="29"> else if metricDest == destHost </span><span class="cov7" title="29">{
                dest = s.hostMetrics
                // metricName = strings.Join([]string{s.hostPrefix, metricName}, config.MetricNameSeparator)
        }</span>

        <span class="cov7" title="29">if dest == nil </span><span class="cov0" title="0">{
                return errors.Errorf("invalid metric destination (%s)-&gt;(%s)", metric, metricDest)
        }</span>

        <span class="cov7" title="29">switch metricType </span>{
        case "c":<span class="cov3" title="4"> // counter
                v, err := strconv.ParseUint(metricValue, 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return errors.Wrap(err, "invalid counter value")
                }</span>
                <span class="cov2" title="3">if v == 0 </span><span class="cov1" title="1">{
                        v = 1
                }</span>
                <span class="cov2" title="3">if sampleRate &gt; 0 </span><span class="cov1" title="1">{
                        v = uint64(float64(v) * (1 / sampleRate))
                }</span>
                <span class="cov2" title="3">dest.IncrementByValue(metricName, v)</span>
        case "g":<span class="cov5" title="10"> // gauge
                if strings.Contains(metricValue, ".") </span><span class="cov2" title="3">{
                        v, err := strconv.ParseFloat(metricValue, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return errors.Wrap(err, "invalid gauge value")
                        }</span>
                        <span class="cov2" title="2">dest.Gauge(metricName, v)</span>
                }<span class="cov4" title="7"> else if strings.Contains(metricValue, "-") </span><span class="cov2" title="2">{
                        v, err := strconv.ParseInt(metricValue, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return errors.Wrap(err, "invalid gauge value")
                        }</span>
                        <span class="cov1" title="1">dest.Gauge(metricName, v)</span>
                }<span class="cov3" title="5"> else {
                        v, err := strconv.ParseUint(metricValue, 10, 64)
                        if err != nil </span><span class="cov1" title="1">{
                                return errors.Wrap(err, "invalid gauge value")
                        }</span>
                        <span class="cov3" title="4">dest.Gauge(metricName, v)</span>
                }
        case "h":<span class="cov4" title="6"> // histogram (circonus)
                fallthrough</span>
        case "ms":<span class="cov5" title="12"> // measurement
                v, err := strconv.ParseFloat(metricValue, 64)
                if err != nil </span><span class="cov2" title="2">{
                        return errors.Wrap(err, "invalid histogram value")
                }</span>
                <span class="cov5" title="10">if sampleRate &gt; 0 </span><span class="cov2" title="2">{
                        v /= sampleRate
                }</span>
                <span class="cov5" title="10">dest.RecordValue(metricName, v)</span>
        case "s":<span class="cov1" title="1"> // set
                // in the case of sets, the value is the unique "thing" to be tracked
                // counters are used to track individual "things"
                dest.Increment(strings.Join([]string{metricName, metricValue}, config.MetricNameSeparator))</span>
        case "t":<span class="cov1" title="1"> // text (circonus)
                dest.SetText(metricName, metricValue)</span>
        default:<span class="cov1" title="1">
                return errors.Errorf("invalid metric type (%s)", metricType)</span>
        }

        <span class="cov6" title="22">s.logger.Debug().
                Str("metric", metric).
                Str("Name", metricName).
                Str("Type", metricType).
                Str("Value", metricValue).
                Str("Destination", metricDest).
                Msg("parsing")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright © 2017 Circonus, Inc. &lt;support@circonus.com&gt;
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

package main

import (
        "github.com/circonus-labs/circonus-agent/cmd"
        "github.com/circonus-labs/circonus-agent/internal/release"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>

// defined during build (e.g. goreleaser, see .goreleaser.yml)
var (
        version = "dev"
        commit  = "none"
        date    = "unknown"
        tag     = ""
)

func init() <span class="cov8" title="1">{
        release.VERSION = version
        release.COMMIT = commit
        release.DATE = date
        release.TAG = tag
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
